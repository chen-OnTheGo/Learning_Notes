
>The lesson to take away is that **initial design decisions determine our code complexity and runtime.**
>*最初的设计决策会直接影响我们代码的复杂性和运行时间。*


这一节我们讨论对不相交集的一些处理方式。

假设有一个社交网络平台，平台上有许多用户，最初每个用户都是一个独立的个体，即没有任何朋友关系。随着时间推移，用户可以通过平台互相添加好友。如果我们需要给平台添加功能，使其能够快速完成如下两个操作：

1. **判断是否已成为好友**：给定两个用户，判断他们是否在同一个朋友圈里，即是否存在好友关系。

2. **合并朋友圈**：当两人成为好友时，将他们的朋友圈合并。

当我们遇到类似于上文的情况 —— ***每个人（或事物）最开始属于各自的独立集合，而随着关系的增加，不断合并成更大的群体。***—— 此时，我们就可以通过利用不相交集的优势来解决类似的问题。


首先，什么是不相交集？

>若两个集合没有共同元素，则它们被称为不相交集合。

即多个集合之间没有共同的元素，每个元素只能属于一个集合。
例如：
我们可以把每个国家视为一个集合，并将在其中生活的人视为元素。同一个人不能同时生活在两个国家里，所以每个国家分别是一个不相交的集合。
而在文章开头的例子中，我们则可以把每个用户都看作元素，而没有在一个朋友圈里、且没有共同好友的两个用户则分别存在于两个不相交的集合中。


>不相交集合（或并查集）数据结构跟踪划分为多个*不相交集合*的固定数量的元素。

不相交集合是一种数据结构，它用于管理多个集合，其中每个集合都是不相交的。这种数据结构可以有效地进行以下两种基本的操作：

1.**查找** ：*确定一个元素是否属于该集合。*

	方法为：
	 isConnected(x, y) : 如果 x 和 y 是连通的（即属于同一个集合），则返回 true 。

2.**合并** ：*将两个集合合并为一个集合。*

	方法为：
	connect(x, y) ：连接 x 和 y 。也称为 union 。


举个形象的栗子：

假设我们有四个元素，分别为`A`、`B`、`C`、`D`，每个元素都在它自己的集合中：

![](../img/Pasted%20image%2020241101200901.png)

调用`connect(A, B)`，将`A`、`B`元素所在的集合合并为一个集合(也可以看作将`A`、`B`元素合并为一个集合)，得到：

![](../img/Pasted%20image%2020241101200915.png)

此时调用`isConnected()`方法：

`isConnected(A, B) => true`
`isConnected(A, C) => false`

# 什么是interface？


不过，我们要怎么来保存这些不相交集合的数据，以便知道每个数据分别属于哪个集合呢？我们又可以用哪种结构或图形来表示这个数据结构呢？接下来，将会展示该数据结构是如何演变的，从**快速查找**（***Quick Find***）到**具有路径压缩的加权快速合并**（***WQU with Path Compression***）。我们将看到，如本文第一句引用所示，设计决策是如何显著影响运行时间和代码复杂性的。


我们可以将不相交集合直观灵活地表示为集合列表，例如`List<Set<Integer>>`。
如果我们有N=5个元素，并且各属于不同的集合，则用集合列表可以表示为：   

`{1}、{2}、{3}、{4}、{5}`

但是，如果我们想执行`connect(4, 5)`。首先，我们需要确定这些集合中的哪个集合包含了这两个元素，这就可能需要通过遍历所有的集合（最坏的情况下），该查找操作的时间复杂度为O(N)。而且若要实现这些方法，代码将非常复杂。

需要强调的是，我们可以很容易地发现，`查找`和 `连接`这两个操作看重的是数据之间的联系（是否属于同一个集合），而不是数据本身。



## 快速查找（Quick Find）


上一个方法在查找元素方面就花费了大量时间，有什么方法可以缩短时间？

查找元素无异于找到元素所在位置，若找到一个能够对元素快速定位的结构，将大大缩短运行时间。那么，什么结构访问特定元素非常方便呢？没错，就是数组。

于是我们考虑使用`一维数组`来表示这些数据。

-  **数组的索引** 代表集合的元素（每个数据）。
-  **每个索引对应的数组元素** 代表该数据所属集合的编号。

例如，我们表示`{0, 1, 2, 4}, {3, 5}, {6}`为：

![](../img/Pasted%20image%2020241101204211.png)

这里的数组索引（0，1，......，6）是元素（数据），其对应的数组元素`id[i]`就是它所属的集合的编号，集合编号相同的两个元素，就表示它们在同一个集合中。

这样，当我们执行`connect(x, y)`时，只需要修改数据对应的集合编号即可（即修改索引对应的数组元素值）。

当执行`isConnected(x, y)`时，就只需要检查数据对应的集合编号是否相同（`id[x] == id[y]`）。这个操作的执行时间是固定的，不会随输入的大小而变化（执行时间复杂度为`Θ(1)`）。

这种实现被称为“**快速查找**”（***Quick Find***），因为该实现查找元素是否相互连接需要的时间是恒定的。

### 代码&运行时间

```
public class QuickFindDS implements DisjointSets{

	private int[] id;
	
	    /* Θ(N) */
	    // 创建数组
	    public QuickFindDS(int N){
	        id = new int[N];
	        for (int i = 0; i < N; i++){
	            id[i] = i;
	        }
	    }
	
	    /* 遍历整个数组，查找所有与元素p在同一集合中的元素，其时间复杂度为 => Θ(N) */
	    public void connect(int p, int q){
	        int pid = id[p];
	        int qid = id[q];
	        for (int i = 0; i < id.length; i++){
	            if (id[i] == pid){
	                id[i] = qid;
	            }
	        }
	    }
	
	    /* Θ(1) */
	    public boolean isConnected(int p, int q){
	        return (id[p] == id[q]);
	    }
}

```

N = DisjointSets数据结构中元素的数量


尽管快速查找在运行时间上优化了很多，并且让`isConnected(x, y)`方法的时间复杂度降为`Θ(1)`，但它的`connect(x, y)`方法操作起来仍然很慢（需要将其中一个集合里的所有元素对应的集合编号都进行修改，才能将两个集合连接起来）。因此，我们需要对`connect(x, y)`进行优化。

怎样才能更简便地合并两个集合，是否可以仅通过修改数据结构中的一个值，就达到此目的？**快速合并**方法可以实现这个功能。



## 快速合并（Quick Union）


在这个方法中，我们只对存储在数组中的元素进行改变，通过给每个集合中的元素分配父元素，例如：

`{0, 1, 2, 4}, {3, 5}, {6}`

分别给元素`2`分配父元素`1`，给元素`1`分配父元素`0`，给元素`4`分配父元素`0`......

![](../img/Pasted%20image%2020241104210742.png)

我们可以把它想象成一种类似于树的结构——以“根节点”为起点，逐层向下分支，类似于树的根部逐渐长出树干和树枝；每个节点又可以生长出多个子节点（相当于树的分支），同时，每个子节点又可以看作一棵子树。

相应地，用数组表示集合时，为每个数据（索引）对应的元素赋值为它的父元素的索引，而不是id。如果某个数据没有父元素，即存在于“最顶部”，则它被称为`root`，咱给它赋值`-1`（或者它本身的索引）：

![](../img/Pasted%20image%2020241104211103.png)
***（`parent`是数组名）***

为了“继承”**Quick Find**的优化成果，我们对**Quick Union**定义了一个辅助函数`find(int item)`，其作用是可以返回`item`所在树的根，例如：对于上面的集合，`find(4) = 0`, `find(1) = 0`等等。每个元素都有唯一的根（`root`）。

若要连接两个元素，我们需要找到每个元素所属的集合（它们各自树的根）, 并使一个元素成为另一个元素的子元素。例如：

假如执行`connect(5, 2)`：

1.***先分别找到两个元素所属集合的标志***：
`find(5)` => `3`;
`find(2)` => `1`;

2.***让其中一棵树的根元素“指向”另一棵树的根元素***：
将`find(5)`的值设置为`find(2)`的值，即`parent[5] = 0`。

得到的结果如图所示：

![](../img/Pasted%20image%2020241104222146.png)

这种方法能带来的最好的情况是，如果`connect(x, y)`中的`x`和`y`都是“根节点”，那么该方法执行过程只是使`x`指向`y`，是一个`Θ(1)`的操作！（因此得名为 **Quick Union**）

这种操作同时也保留了Quick Find的优点。若要判断两个元素是否属于同一个集合，只需要判断它们的根节点是否相同。所以在调用`isConnected(x, y)`时，只需判断`find(x) == find(y)`。


### Performers

但是Quick Union 仍有着一个潜在的问题：在不断连接两个集合后，"这棵树"可能会变得很长。对于底部的子节点，若要去查找它的根节点（即调用`find(int item)`），要一步一步“向上遍历”，可以说是很困难的。

![](../img/Pasted%20image%2020241104223144.png)

在这种情况下，我们必须遍历所有节点才能到达根节点，其执行时间为`Θ(N)`。由于我们在使用`connect(x, y)`和`isConnected(x, y)`方法时，都会相应地调用`find(item)`，因此这两个方法的时间复杂度为`O(N)`。

我们可以得出结论——树越矮，查找速度越快！

## Weighted Quick Union(WQU)

于是我们给 **Quick Union** 制定一个新的规则：***每当我们调用 `connect` 时，我们总是将较小树的根链接到较大树***。

循此规则将为组合后的树提供最大高度 `logN` ，其中 `N `是我们的 Disjoint Sets 中的元素数量。

例如，请考虑连接下面的两组 T1 和 T2：

![](../img/Pasted%20image%2020241107095018.png)

我们有两种连接方式：

将T1的`root`连向T2的`root`，和将T2的`root`连向T1的`root`。

![](../img/Pasted%20image%2020241107095101.png)

**Option2 更可取**，因为它只有 2 个高度。根据我们的新规则，我们也会选择第二个选项，因为 T2 比 T1 小（大小为 3 而不是 6）。

我们通过树中的节点数量来确定树的大小。若要判断更适合连接哪棵树，就需要知道树的大小。为了便于记录，我们将标志`“-1”`替换为 `“-（tree 的大小）”` 来将此信息存储在树的根中。

这样，就能在一定程度上缩短运行时间。

还有更好的方法吗？



## Weighted Quick Union with Path Compression


聪明的你一定能发现，每当我们调用`find(x)`时，我们都必须从`x`遍历到`root`，例如：调用`isConnected(15, 10)`时，我们需要先找到元素`15`的`root`和元素`10`的`root`，判断两者的`root`是否相同，这个过程就需要不断遍历，直到找到`root`。如果结构如图，就显得及其复杂: 

![](../img/Pasted%20image%2020241106124910.png)

若要尽可能缩短`find(x)`操作所需的时间，我们就需要缩短从`x`到`root`之间的路径。如果我们直接让该路径上（沿途）的每个节点都指向根节点，如图：

![](../img/Pasted%20image%2020241106125955.png)

那么只需遍历一次，就能够找到`root`，大大缩短了时间。
相当于：

![](../img/Pasted%20image%2020241106130228.png)

如果每次调用 `find(x)` 方法时，都将沿途遇到的所有节点直接连接到根节点上，从而“压缩”了路径，降低了“树”的高度。这样一来，在后续的 `find` 方法调用中，就不再需要遍历整个路径，而是直接锁定`root`，更快地找到根节点。一旦调用的次数足够多，这棵树的高度为`1`，即每个子节点都直接指向根节点。
从长远看，`connect` 和 `isConnected`的平均运行时间几乎不变，这种“平均的”长期复杂度称为 **摊销运行时**。



## 总结


![](../img/Pasted%20image%2020241106222423.png)

![](../img/Pasted%20image%2020241106223047.png)

本文谈到从**Quick Find** 到  **WQU with Path Compression** 的演变过程。相同的一组数据却可以用不同的方式来表达，当然，其效果与成本也是不尽相同。选择什么样的模型、结构，将会直接影响我们代码的复杂性和运行时间。高效的代码，能够减少时间和空间的消耗，为解决复杂的现实问题提供强有力的工具。


###### 参考：https://www.youtube.com/playlist?list=PLnp31xXvnfRpMlYLU0hWYDMHNtcGi-Qmm