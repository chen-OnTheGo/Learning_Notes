
1. 理解操作系统的设计和实现
2. 通过一个小型操作系统获得实践经验，即XV6操作系统

（除了查看现有的操作系统，还可以从lab中获得很多经验：扩展操作系统、改进操作系统、编写在应用程序运行时使用的操作系统接口的系统软件）


不同的操作系统通常都有共同的目标：
- 对硬件进行抽象
- 在许多应用程序中实现硬件复用（多路复用）
- 隔离性（Isolation），一般情况下不同的活动不应该相互干涉
- 允许分享（例如，使用编辑器创建了一个文件，并希望编译器可以读取该文件）
- 安全系统或权限系统，即一个访问控制系统（用户想分享信息的时候分享，不想分享就不分享）
- 操作系统必须确保它所提供的服务都不会阻碍应用程序获得高性能，甚至能够帮助其获得良好的性能
- 大多数操作系统都必须支持各种不同的应用程序



#### 系统调用概述

系统调用举例：
![](../../img/Pasted%20image%2020251010110516.png)
这些看起来与函数调用类似，但不同的是，系统调用需要跳转到内核(kernel)，而内核具有特殊的权限，它可以直接访问各种硬件，可以修改各种敏感和受保护的硬件资源，比如直接访问硬盘


对于应用程序开发人员来说，真正深入理解操作系统有多重要？一定要是专家吗？

> 不必成为专家，但如果你花了很多时间开发、维护和调试应用程序，你最终会了解很多关于操作系统的信息，无论你是否有意，它就这样出现了，而且你经常被迫理解它。

#### exec系统调用

`exec`是一个用于替换当前进程的命令。在 Unix/Linux 系统中，`exec`会将当前运行的进程替换为指定的程序或命令（我理解为将exec作用的进程的优先级设为比当前正在执行的程序高，并中断，接着运行目标程序）

#### wait系统调用

**`wait` 系统调用的作用**：

- **等待子进程结束**：当一个进程调用 `wait` 系统调用时，它会被挂起，直到它的子进程之一结束为止。
- **回收子进程的资源**：`wait` 允许父进程获取子进程的退出状态，这样父进程可以知道子进程是如何结束的（正常退出还是出现错误）。这也是防止子进程成为**孤儿进程**的机制。