
### int类型

==一般而言，存储一个`int`要占用一个机器字长。==因此，早期的16位IBM PC 兼容机使用16位来存储一个`int`值，其取值范围为`-32768 ~ 32767`。目前个人计算机一般是32位，因此用32位存储一个`int`值。现在，个人计算机产业正逐步向着64位处理器发展，自然能存储更大的整数。ISO C 规定`int`的取值范围最小为`-32768 ~ 32767`。==一般而言，系统用一个特殊位的值表示有符号整数的正负号。==


#### 初始化变量

初始化（initialize）变量就是为变量赋一个初始值。在C语言中，初始化可以直接在声明中完成。只需在变量名后面加上赋值运算符和待赋给变量的值即可。如下所示：
```
int lines = 1;
int dogs = 1, goats = 3;
int dog, goats = 3;   // 该行有效，但这种格式很糟糕
```

上面示例的第三行，容易让人误以为`dog`也被初始化为`3`，所以==最好别把初始化的变量和未初始化的变量放在同一条声明中。==

简而言之，==声明为变量创建和标记存储空间，初始化为其指定初始值。==

![](../../../img/Pasted%20image%2020250925205202.png)


#### 转换说明

在用`printf()`函数打印`int`类型的值时。`%d`指明了在一行中打印整数的位置，`%d`称为转换说明，它指定了`printf()`应使用什么格式来显示一个值。作为程序员，要确保转换说明的数量与待打印值的数量相同，编译器不会捕获这类型的错误。下面是一个例子：
```
...
int ten = 10;
printf("%d minus %d is %d", ten);
...
```

编译并运行该程序，输出如下：
```
10 minus 16 is 165039284
```

其中，第一个`%d`对应`ten`的值，但是由于没有给后两个`%d`提供任何值，所以打印出来的值是内存中的任意值（我们在运行这个程序时，每次运行显示的这两个数值都不同，因为内存中存储的数据不同，而且编译器管理内存的位置也不同。我尝试了两次输出，输出结果如下图）

![](../../../img/Pasted%20image%2020250925210530.png)


`int`类型有那么多，应该如何选择？首先，考虑`unsigned`类型，这种类型的数常用于==计数==，因为计数不用负数。而且，`unsigned`类型可以表示更大的正数。
如果一个数超出了`int`类型的取值范围，且在`long`类型的取值范围内时，使用`long`类型。然而，对应那些`long`==占用的空间==比`int`大的系统，使用`long`类型会==减慢运算速度==。因此，==如非必要，请不要使用`long`类型==。
另外要注意一点，若在`long`类型和`int`类型==占用空间相同==的机器上编写代码，当确实需要32为的整数时，==应使用`long`类型而不是`int`类型，以便把程序移植到16位机后仍然可以正常运作==。
（如果写代码时用了 `int`，在 32 位机器上没问题，但移植到 16 位机时，`int` 变成了 16 位，数据可能溢出、出错。如果用 `long`，不管在哪个平台，它都保证是 32 位，这样代码在 16 位机上也能正确运行。）

类似地，如果确实需要64位的整数，应使用`long long`类型。

如果在`int`设置为32位的系统中要使用16位的值，应==使用`short`类型以节省存储空间==。通常，只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题。（不过在一般小规模的变量使用场景下，节省这点空间意义不大，因为现代系统内存足够大，所以没必要过度追求“省一点空间”。）使用`short`类型的另一个原因是，计算机中某些组件使用的硬件寄存器是16位。


整数溢出，可以把整数看作汽车的里程表，当达到它能表示的最大值时，会重新从起始点开始。

在给函数传递参数时，C编译器把`short`类型的值自动转换成`int`类型的值。那么，为什么要进行转换？`h`修饰符有什么用？

首先，`int`类型被认为是计算机处理整数类型时最高效的类型。因此，在`short`和`int`类型的大小不同的计算机中，用`int`类型的参数传递速度更快。
使用`h`修饰符可以显示较大整数被阶段成`short`类型值的情况。

> 在使用`printf()`函数时，切记检查每个待打印值都有对应的转换说明，还要检查转换说明的类型是否与待打印值的类型相匹配。


#### char类型

`char`类型用于存储字符，但是从技术层面来看，`char`是整数类型。因为`char`类型实际上存储的是整数而不是字符。计算机使用数字编码来处理字符，即用特定的整数表示特定的字符。美国最常用的编码是ASCII编码（许多IBM的大型主机使用另一种编码—— `EBCDIC`，其原理相同）。

标准ASCII码的范围是0~127，只需7位二进制数即可表示。通常，`char`类型被定义位8位的存储单元，因此容纳标准ASCII码绰绰有余。

C语言把1字节定义位`char`类型占用的位（bit）数，因此无论是16位还是32位系统，都可以使用`char`类型。

在C语言中，用单引号括起来的单个字符被称为字符常量。编译器以发现`'A'`，就会将其转换成相应的代码值。下面是一些例子：
```
char c;
c = 'T';    // 赋值正确
c = T;    // 错误，这里的T是一个变量
c = "T";    // 错误，这里的"T"是一个字符串
```

实际上，字符是以数值形式存储的，所以也可使用数字代码值来赋值。例如：
```
char grade = 65;
```

虽然`65`是`int`类型，但它在`char`类型能表示的范围内，所以该赋值没问题，等效于：
```
char grade = 'A';
```

但用数字代码值来赋值是一种不好的编程风格。需要注意的是，==这种等效的前提是系统使用的是ASCII码==。用字符常量在任何系统中都不会出问题。因此，==最好使用字符常量==，而不是数字代码值。

奇怪的是，C语言将字符常量视为`int`类型而非`char`类型。
例如，在`int`为32位、`char`为8位的ASCII系统中，有下面的代码：
```
char grade = 'B';
```
本来`'B'`对应的数值`66`存储在32位的存储单元中，现在却可以存储在8位的存储单元中。利用字符常量的这种特性，可以定义一个字符常量`'FATE'`，即把4个独立的8位ASCII码存储在一个32位的存储单元中。当我们把这样的字符常量赋给`char`类型变量`grade`，由于其只有8位存储单元，所以==只有最后8位有效==。因此，`grade`的值是`E`。