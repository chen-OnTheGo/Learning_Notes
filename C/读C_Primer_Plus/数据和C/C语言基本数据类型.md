
### int类型

==一般而言，存储一个`int`要占用一个机器字长。==因此，早期的16位IBM PC 兼容机使用16位来存储一个`int`值，其取值范围为`-32768 ~ 32767`。目前个人计算机一般是32位，因此用32位存储一个`int`值。现在，个人计算机产业正逐步向着64位处理器发展，自然能存储更大的整数。ISO C 规定`int`的取值范围最小为`-32768 ~ 32767`。==一般而言，系统用一个特殊位的值表示有符号整数的正负号。==


#### 初始化变量

初始化（initialize）变量就是为变量赋一个初始值。在C语言中，初始化可以直接在声明中完成。只需在变量名后面加上赋值运算符和待赋给变量的值即可。如下所示：
```
int lines = 1;
int dogs = 1, goats = 3;
int dog, goats = 3;   // 该行有效，但这种格式很糟糕
```

上面示例的第三行，容易让人误以为`dog`也被初始化为`3`，所以==最好别把初始化的变量和未初始化的变量放在同一条声明中。==

简而言之，==声明为变量创建和标记存储空间，初始化为其指定初始值。==

![](../../../img/Pasted%20image%2020250925205202.png)


#### 转换说明

在用`printf()`函数打印`int`类型的值时。`%d`指明了在一行中打印整数的位置，`%d`称为转换说明，它指定了`printf()`应使用什么格式来显示一个值。作为程序员，要确保转换说明的数量与待打印值的数量相同，编译器不会捕获这类型的错误。下面是一个例子：
```
...
int ten = 10;
printf("%d minus %d is %d", ten);
...
```

编译并运行该程序，输出如下：
```
10 minus 16 is 165039284
```

其中，第一个`%d`对应`ten`的值，但是由于没有给后两个`%d`提供任何值，所以打印出来的值是内存中的任意值（我们在运行这个程序时，每次运行显示的这两个数值都不同，因为内存中存储的数据不同，而且编译器管理内存的位置也不同。我尝试了两次输出，输出结果如下图）

![](../../../img/Pasted%20image%2020250925210530.png)


`int`类型有那么多，应该如何选择？首先，考虑`unsigned`类型，这种类型的数常用于==计数==，因为计数不用负数。而且，`unsigned`类型可以表示更大的正数。
如果一个数超出了`int`类型的取值范围，且在`long`类型的取值范围内时，使用`long`类型。然而，对应那些`long`==占用的空间==比`int`大的系统，使用`long`类型会==减慢运算速度==。因此，==如非必要，请不要使用`long`类型==。
另外要注意一点，若在`long`类型和`int`类型==占用空间相同==的机器上编写代码，当确实需要32为的整数时，==应使用`long`类型而不是`int`类型，以便把程序移植到16位机后仍然可以正常运作==。
（如果写代码时用了 `int`，在 32 位机器上没问题，但移植到 16 位机时，`int` 变成了 16 位，数据可能溢出、出错。如果用 `long`，不管在哪个平台，它都保证是 32 位，这样代码在 16 位机上也能正确运行。）

类似地，如果确实需要64位的整数，应使用`long long`类型。

如果在`int`设置为32位的系统中要使用16位的值，应==使用`short`类型以节省存储空间==。通常，只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题。（不过在一般小规模的变量使用场景下，节省这点空间意义不大，因为现代系统内存足够大，所以没必要过度追求“省一点空间”。）使用`short`类型的另一个原因是，计算机中某些组件使用的硬件寄存器是16位。


整数溢出，可以把整数看作汽车的里程表，当达到它能表示的最大值时，会重新从起始点开始。

在给函数传递参数时，C编译器把`short`类型的值自动转换成`int`类型的值。那么，为什么要进行转换？`h`修饰符有什么用？

首先，`int`类型被认为是计算机处理整数类型时最高效的类型。因此，在`short`和`int`类型的大小不同的计算机中，用`int`类型的参数传递速度更快。
使用`h`修饰符可以显示较大整数被阶段成`short`类型值的情况。

程序员还必须根据待打印值的类型使用正确的转换说明