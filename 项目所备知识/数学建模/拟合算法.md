
拟合算法和[插值算法](插值算法.md)的思想非常接近，但它们也是有区别的：

![](../../img/Pasted%20image%2020250820164046.png)

插值是“必须经过所有点”；拟合是“允许有误差，但整体更平滑或更合理”。


### 示例

![](../../img/Pasted%20image%2020250820164251.png)

![](../../img/Pasted%20image%2020250820164302.png)

如何确定`k`和`b`的值？其中一种方法是最小二乘法，一般用第二种定义

![](../../img/Pasted%20image%2020250820164553.png)

![](../../img/Pasted%20image%2020250820165121.png)

`arg`代表参数
![](../../img/Pasted%20image%2020250820164826.png)

求解最小二乘法：

![](../../img/Pasted%20image%2020250820165237.png)

![](../../img/Pasted%20image%2020250820165421.png)

拟合后如何知道拟合的效果如何？

![](../../img/Pasted%20image%2020250820165910.png)

![](../../img/Pasted%20image%2020250820170410.png)

由于`SSE`会受量纲(单位)的影响，所以为了统一量纲，我们用`SST = SSE + SSR`。

可以多试几个拟合函数，并分别求出其对应的R<sup>2</sup>，哪个函数的R<sup>2</sup>越接近1，就选择这个函数作为拟合函数。

但由于选择的函数的最高次数越大，其拟合效果越好，但我们用拟合函数是为了选择一个简单的函数，所以需要综合R<sup>2</sup>和函数的复杂度来进行取舍（不是SSE越小越好）。

但不是所有函数都有R<sup>2</sup>，R<sup>2</sup>只能用于拟合函数是线性函数时
![](../../img/Pasted%20image%2020250820171348.png)

那如何鉴定线性函数？

![](../../img/Pasted%20image%2020250820171454.png)

![](../../img/Pasted%20image%2020250820171625.png)

如果不能用R<sup>2</sup>，就用`SSE`来比较并取舍。


### 计算

![](../../img/Pasted%20image%2020250820171947.png)

### 曲线拟合器

![](../../img/Pasted%20image%2020250820173616.png)

导入数据后，右下方就能得出计算值：

![](../../img/Pasted%20image%2020250820174238.png)

![](../../img/Pasted%20image%2020250820174507.png)


![](../../img/Pasted%20image%2020250820174840.png)

可以选择“生成代码”后，将代码复制粘贴至自己的代码中，既可以看结果，又能提高自己代码的规范性。


### 示例

![](../../img/Pasted%20image%2020250820175033.png)

![](../../img/Pasted%20image%2020250820175102.png)


### 优秀论文中的cftool运用

![](../../img/Pasted%20image%2020250820182258.png)

![](../../img/Pasted%20image%2020250820182317.png)

还是建议用其他工具来绘制3D图，而不是cftool。