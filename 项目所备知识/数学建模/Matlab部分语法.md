
注：符号用英文输入法输入。

用`%`表示注释，若想一次性选中多行注释，可以用`Ctrl`+`R`。取消多行注释需要用`Ctrl`+`T`。

某行的最后加上分号，表示不显示该行的运算结果（一般我们不需要看见中间语句的运算结果，所以一般中间语句都要加分号）；不加分号，当运行该句时，会显示运算结果。

`clear`可以清除工作区的所有变量。

`clc`可以清除命令行窗口中的内容（清屏）。

一般会两个一起用：`clear;clc`（这里的分号用于区分行），一般这条语句会出现在很多代码开头，起到“初始化”的作用，防止之前的结果对新脚本文件产生干扰。

`disp()`是输出函数(其结尾加不加分号都一样)，类似于C语言中的printf()函数：
```
disp('Hello world')
```

矩阵中同一行中间用逗号分隔，也可以直接用空格：
```
% 举例一个行向量
a = [1,2,3]
a = [1 2 3]
% 上面两种表达方式等效
```

分号则用来分隔行：
```
% 列向量的表达方式
a = [1;2;3]
```


合并字符串的两种方法：
```
% 用strcat(str1,str2,...,strn)
strcat('字符串1','字符串2')

% [str1,str2,...,strn] 或 [str1 str2 ... strn](逗号或空格隔开)
[str1, str2]
[str1 str2]
```


`num2str`可以用来将数字转换为字符串：
```
c = 100
num2str(c)
```


`input`函数是输入函数，可以将我们输入的内容（数字、矩阵、向量等都可以）赋给一个变量
```
A = input('请输入A的值：')
```


#### sum函数

- 若是向量（行向量或列向量），都是直接求和。
```
E = [1 2 3]
sum(E)

B = [1;2;3]
sum(B)

% 上面两种情况输出都为6
```

- 如果是矩阵，则需要根据行和列的方向作区分:
	- ==`a=sum(x)` 或 `a=sum(x,1)`表示按列求和（得到一个行向量）。==
	```
	E = [1,2;3,4;5,6]
	
	% a=sum(x)表示按列求和（得到一个行向量）
	a = sum(E)
	% 最后计算得 a = [9,12]
	```

	- ==`a=sum(x,2)` 表示按行求和（得到一个列向量）。==
	```
	E = [1,2;3,4;5,6]
	a = sum(E,2)
	% 最后计算得 a = [3;7;11]
	```

	【`dim=1`表示按照列，`dim=2`表示按照行，默认dim=1】

	- ==`a=sum(sum(x))` 或 `a=sum(x(:))` 表示对整个矩阵求和==
	```
	E = [1,2;3,4;5,6]
	a = sum(sum(E))
	% E(:)表示将矩阵E拼接成一个列向量[1;2;3;4;5;6]
	a = sum(E(:))
	```



#### 提取矩阵中指定位置的元素

- 提取某行某列的一个元素
```
A = [1,2,3;4,5,6;7,8,9]
A(2,1) % 表示取A矩阵中第二行第一列的元素：4
```

- 取某一行的全部元素（输出的是一个行向量）
```
A(2,:) % 表示取矩阵A第二行的全部元素（:代表所有元素）
```

- 取某一列的全部元素（输出的是一个列向量）
```
A(:,2) % 表示取矩阵A第二列的全部元素（:代表所有元素）
```

- 取指定的某些行的全部元素（输出的是一个矩阵）
```
A([2,5],:)   % 取第二行和第五行的元素
A(2:5,:)     % 取第二行到第五行的元素（一共四行元素）
A(2:2:5,:)   % 取第二行和第四行（从第二行开始，每次递增2个单位，到第五行结束）
A(2:end,:)   % 取第二行到最后一行上的元素
A(2:end-1,:) % 取第二行到倒数第二行上的元素
```
```
1:10:100
% 表示从一开始，每过10个数取一次，一直到100
% 上面例子的值是：1 11 21 31 41 51 61 71 81 91
```

- 取全部元素（按列拼接，最终输出的是一共列向量）
```
A(:)
```


#### size函数

`size(A)` 函数用来求矩阵A的大小的，返回值是一个行向量，该向量的第一个元素是矩阵的行数，第二个元素是矩阵的列数
```
[r,c] = size(A)

% 将矩阵A的行数赋给 r
r = size(A,1)
% 将矩阵A的列数赋给 c
c = size(A,2)
```


#### repmat函数
`B = repmat(A,m,n)` 得到的矩阵B是由m行n列的矩阵A组成。（将矩阵A看作一个整体，看作一个元素）
```
A = [1,2,3;4,5,6]
B = repmat(A,2,1)
```
这个例子的运行结果如下：
![](../../img/Pasted%20image%2020250816162249.png)
（由两行一列的A矩阵组成）


#### 矩阵的运算

- `A * B` 代表矩阵之间相乘，`/`代表矩阵之间的除法`(A/B = A*inv(B))`
（`inv(B)` 代表求B的逆矩阵）


- 两个行数列数相同的矩阵对应元素之间的乘除法需要使用`.*` 和 `./`
```
A = [1,2;3,4]
B = [2,6;3,0]
A.*B % 结果为[2,12;9,0]
A./B % 结果为[1/2,1/3;inf]，其中inf表示无穷的意思
```

- 矩阵每个元素都乘或除以一个数
```
A * 2 等效于 A .* 2
A / 2 等效于 A ./ 2
```

- 矩阵每个元素都乘方，只能用`.^`。
```
A .^ 2
```


#### 求特征值和特征向量

`eig(A)`

![](../../img/Pasted%20image%2020250816165440.png)


#### find函数的基本用法

- 用来返回向量或矩阵中不为0的元素的位置索引。
```
% 向量
X = [2 6 1 0 4 0 0 0]
ind = find(X)
% 最后ind的值为[3 5 6 7]（从0开始计数）

% 返回前两个不为0的元素的位置
find(X,2)


% 矩阵
X = [1 2 0;0 0 8;5 0 8]
% 当执行find函数时，会先将矩阵X按每列来看作[1;0;5;2;0;0;0;8;8]
% 故返回[1;3;4;8;9]
% 因为Matlab在存储矩阵时，是一列一列存储的

% r得到非0元素所在的行数，c表示非0元素对应的列
[r,c] = find(X)
```


#### 大小判断运算

大于：`>`，小于：`<`，判断是否相等：`==`。


#### 判断语句

语句最后一定要以`end`结尾

```
a = input('输入A的值')
if a > 0
	disp('a为正数')
elseif a == 0
	disp('a为0')
else
	disp('a为负数')
end
```


#### magic函数

A = magic(5) % 幻方矩阵

`M = magic(n)` 返回由1到n^2的整数构成并且总行数和总列数相等的n×n矩阵。阶次n必须为大于或等于3的标量。


#### sort()

`sort(A)`若A是向量不管是列还是行向量，默认都是对A进行升序排列。`sort(A)`是默认的升序，而`sort(A,'descend')`是降序排序。

`sort(A)`若A是矩阵，默认对A的各列进行升序排列

`sort(A,dim)`

`dim=1`时等效sort(A)

`dim=2`时表示对A中的各行元素升序排列

`A = [2,1,3,8]`

Matlab中给一维向量排序是使用sort函数：`sort（A）`，排序是按升序进行的，其中A为待排序的向量；

若欲保留排列前的索引，则可用
`[sA,index] = sort(A,'descend') ` ，排序后，sA是排序好的向量，index是向量sA中对A的索引。


#### 定义函数

`function [输出变量] = 函数名称(输入变量）`

函数的中间部分都是函数体

函数的最后要用end结尾

输出变量和输入变量可以有多个，用逗号隔开

例如：
```
function [a,b,c]=test(d,e,f)
	a=d+e;
	b=e+f;
	c=f+d;
end
```
 
自定义的函数要单独放在一个m文件中，不可以直接放在主函数里面（和其他大多数语言不同）。


#### 关于当前文件夹的问题

当我们需要把数据的表格`load`并处理时，明明表格跟代码在同一路径下，为什么却显示：
![](../../img/Pasted%20image%2020250817162630.png)

是因为Matlab中的“当前文件夹“需要切换到装有这两个文件的文件夹下

![](../../img/Pasted%20image%2020250817162900.png)


#### mean()函数

`mean()`函数用来计算平均值（算术平均值）

- 对向量
```
A = [1 2 3 4 5];
m = mean(A)

% 结果为：m = 3
```

- 对矩阵（默认对每一列求平均，返回一个行向量）
```
B = [1 2 3; 4 5 6];
m = mean(B)

% 结果：m = [2.5000 3.5000 4.5000]
```

```
m1 = mean(B, 1)   % 按列求平均（默认）
m2 = mean(B, 2)   % 按行求平均
```

- 忽略NaN值（会自动跳过 `NaN`，而不是让结果变成 `NaN`）
```
C = [1 NaN 3; 4 5 NaN];
m = mean(C,'omitnan')

% 结果：m = 2.5    5.0    3.0
```
