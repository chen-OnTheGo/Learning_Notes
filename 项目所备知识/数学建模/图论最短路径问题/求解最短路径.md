
本节将求解最短路径的两个方法：[Dijkstra 算法](求解最短路径.md#Dijkstra%20算法)（迪杰斯特拉算法）和 [Bellman–Ford Algorithm](求解最短路径.md#贝尔曼-福特算法)（贝尔曼福特算法）。

摘自ChatGPT：

这两个算法都用来解决**单源最短路径问题**，但思路和适用场景有差别。可以这样理解：

**共同点**：

- 都是解决“从一个起点出发到所有顶点的最短路径”的问题。
- 都适用于带权图（有向或无向）。

**Dijkstra 算法（迪杰斯特拉算法）**：

- **作用**：求解单源最短路径，要求所有边==权值非负==。
- **核心思想**：采用贪心策略，每次选择当前距离起点最近的顶点，并更新它的邻接点的最短距离。
- **复杂度**：用优先队列优化后是 `O(Elog⁡V)`，效率较高。
- **特点**：==速度快，但不能处理负权边。==

**Bellman–Ford 算法**：

- **作用**：求解单源最短路径，可以处理**含负权边**的图，并能检测是否存在**负权回路**。
- **核心思想**：不断“松弛”所有边，最多进行 `∣V∣−1` 轮迭代，直到最短路径稳定。
- **复杂度**：`O(VE)`，比 Dijkstra 慢得多。
- **特点**：鲁棒性强，能处理负权情况，但==在大规模稠密图里效率低。==

**区别总结一句话**：
- ==如果图里没有负权边 → 用 **Dijkstra**，更快；==
- ==如果图里可能有负权边 → 用 **Bellman–Ford**，还能检测负权回路。==

### Dijkstra 算法

![](../../../img/Pasted%20image%2020250821201651.png)

演示看视频：https://www.bilibili.com/video/av54668527

#### 缺点

==Dijkstra 算法不能处理负权重的图。==

![](../../../img/Pasted%20image%2020250821204946.png)

该如何修复这个缺点？


### 贝尔曼-福特算法

![](../../../img/Pasted%20image%2020250821205158.png)

但贝尔曼‐福特算法不支持含有负权回路的图。

那么，什么是负权回路？

如果存在一个环（从某个点出发又回到自己的路径），而且这个环上所有权值之和是负数，那这就是一个负权环，也叫负权回路。

![](../../../img/Pasted%20image%2020250821205436.png)

所以，==贝尔曼‐福特算法实际上处理的是具有负权重的有向图。（且该有向图也不能含有负权回路）==

庆幸的是，含有负权重的图特别少见，且一旦出现负权重，也往往是在有向图中。因此不用担心算法求解不出来的问题。


#### Matlab计算最短路径

![](../../../img/Pasted%20image%2020250821205718.png)

![](../../../img/Pasted%20image%2020250821205749.png)

![](../../../img/Pasted%20image%2020250821205938.png)

可在Matlab中用`highlight()`来高亮强调最短路径。

![](../../../img/Pasted%20image%2020250821205951.png)

![](../../../img/Pasted%20image%2020250821210023.png)

`[nodeIDs,dist] = nearest(G,s,d [,'Method',algorithm])`

返回图形 G 中与节点 `s` 的距离在 `d` 之内的所有节点。
`nodeIDs` 是符合条件的节点
`Dist` 是这些节点与s的距离