
在本单元中，我们开始讨论虚拟机的实现，而上一节已经完成了[the Stack](the%20Stack.md)的实现。在本节中，我们将继续实现内存段。

我们从一个与抽象的内存空间交互的stack开始了这段虚拟机之旅，接着，我们用八个内存段替换了这个抽象空间，它们分别为：`local`、`argument`、`this`、`that`、`constant`、`static`、`pointer`、`temp`。
![](../../../../../../img/Pasted%20image%2020250919220233.png)

现在的问题是，如何在host computer上实现这些Memory Segments。

在开始之前，我们可以看到，这些内存段的抽象非常统一，都是需要我们使用完全相同的语法（`push segment i`或`pop segment i`）来处理任何分段中的任何位置。那么我们该如何实现这些内存段？

一步一步地来，我们先实现`local`内存段，该如何在主机RAM上实现该内存段？

#### local内存段

在上一节stack实现的基础上（从地址为256的位置开始stack，使用一个名为`SP`的指针来记录stack中下一个可用位置的地址，并将`SP`映射到host computer内存中的`RAM[0]`上），我们来实现`local Segment`。

原则上可用将`local Segment`放在RAM上我们想要的任何地方，只要我们能记住这个区块的基址（基本地址），就不用在乎`local Segment`将存储在哪里。

于是，我们决定将`local Segment`的基址放在名为`LCL`的指针中，并将`LCL`映射到`RAM[1]`上。

![](../../../../../../img/Pasted%20image%2020250924170213.png)

如图所示，我们有两个指针，其中`SP`指针指向stack中的下一个可用位置，`LCL`指向`local Segment`的基址。现在执行`pop local 2`，执行的过程会是什么样的呢？

首先我们可以看到`local segment`的基址为`1015`，偏移量（索引）为`2`，通过将基址与偏移量相加，我们得到存储弹出值的目标地址的值。
接着，将`SP`中的值减一，变成了图中右侧所示的`257`，这意味着，`RAM[257]`中的值（也就是`5`）失效了，若下次再往里面放入某个值，将直接把这里的`5`覆盖掉。

因此，当我们管理一个stack时，这个stack里面有各种各样的垃圾（残留的数据），这是很常见的。然而，stack中的指针又能准确地表示stack的哪一部分是有效区域（当前函数正在使用的区域），哪一部分是可以忽略或覆盖的无效数据。便于我们管理。

![](../../../../../../img/Pasted%20image%2020250924170534.png)

于是实现的步骤为：
```
addr = LCL+2
SP--
*addr = *SP
```

同理可得，`pop segment i`的实现步骤为：
```
addr = LCL+i
SP--
*addr = *SP
```

`push segment i`的实现步骤为：
```
addr = LCL+i
*SP = *addr
SP++
```


#### local、argument、this、that四个内存段

现在让我们扩展一下，一起谈谈`local`、`argument`、`this`、`that`这四个部分，思考一下这些Segments来自哪里，或者说它们有什么用处？

![](../../../../../../img/Pasted%20image%2020250924221110.png)

在现实中，比如说Java方法调用，一个方法在运行时往往会用到局部变量（local variables）、参数变量（argument variables）、当前对象的成员变量/字段（this指向的对象的属性）、数组或其他数据结构（可能由that指针引用）。

当我们将这些逻辑抽象成虚拟机模型时，虚拟机也必须能表达出这些语义，因此，我们使用`local`、`argument`、`this`、`that`这些内存段。

![](../../../../../../img/Pasted%20image%2020250924221834.png)

`this Segment`存储当前对象的成员变量或字段的值，`that Segment`存储当前方法可能正在处理的数组的值。因此，基本上，虚拟机设计了这四个段，就是为了在 **虚拟机层面** 保留并体现现实语言运行时的数据含义（语义）。

那我们如何实现这四个内存段呢？

首先，我们需要记住的是，从概念上说，我们使用它们的方式完全相同。我们需要`push/pop`、`segments`、`index`这些信息，除此之外我们不需要任何东西，因此可以统一访问它们，同样，我们也可以用完全相同的方式实现它们。

除了始终可用的stack指针`SP`，我们还将增加四个指针，分别为`LCL`、`ARG`、`THIS`、`THAT`。并且这四个指针与`local Segment`中的`LCL`指针的做法完全相同，都指向相应内存段的基址。

![](../../../../../../img/Pasted%20image%2020250925111223.png)

因此，其`pop`和`push`命令的实现也将完全相同。同样地，我们也不需要去关注这些片段位于RAM上的哪个部分，我们所要做的就是记住这些动态分配的基本地址。

在本课程的后面我们将看到如何分配这些片段在内存中的位置。这是一个非常有趣的问题，我们将使用操作系统中的各种巧妙的算法来解决这个问题，以及和编译器共同决定在RAM上映射这些段的位置。


#### constant内存段

接下来我们将讨论`constant`这个内存段。

当编译器在源代码里面看到一个常量时，需要在VM里表示它，这时，编译器将生成VM指令，使用`constant`段来表示这个常量值。因此，它将使用类似于`push constant 常量`或 `pop constant 常量`的操作来表达。
如何实现这些操作？值得注意的是，常量即无法改变的量，因此，在`constant`中存储一些东西是没有意义的，不能被写入，也就没有`pop`这类的指令。只有`push constant i`是合法的，用来把一个立即数压入栈。

`constant`段的实现很简单，因为这是一个真正的虚拟段，在物理内存中并没有对应的存储区域。当我们运行`push constant i`命令时，我们只需要把常量`i`放到栈上，不需要去找`constant`段里的第5个位置。

所以，`push constant i`的实现步骤为：
```
*SP = i
SP++
```
这就是对`constant`段的处理。


#### static内存段

接着我们讨论`static`段。

首先需要了解的是，[静态变量](静态变量.md)的特点和含义。根据其特点，可以得出，我们需要将静态变量存储在某个全局内存区域中，这样，所有由这些VM函数生成的代码都能访问到同一个静态变量。

> So, the decision that we decide to undertake is to have the VM translator, translate the reference to static i in some vm file `Foo.vm` into the assembly reference `Foo.i`

所以我们决定，让VM translator把`Foo.vm`这个文件里面对静态变量`i`的引用，翻译成汇编中的`Foo.i`引用。（这里的`Foo`是文件的名称，`i`则取自VM command的索引。比如`static 2`，则`i`为2）

![](../../../../../../img/Pasted%20image%2020250925124745.png)

如何实现`pop static 5`？VM translator会把这条指令翻译成几条Hack汇编指令来实现（下图中省略了这部分）。从栈顶把值弹出，存到[D寄存器](Hack语言规范.md#D寄存器)中（由于静态变量`static 5`对应Hack汇编里面的一个标签，比如`Foo.5`），下一步就是把D寄存器的值写入`Foo.5`对应的RAM地址。
其他静态变量的处理方式也是如此，只是索引不同，例如 `static 2` 对应 `Foo.2`。

![](../../../../../../img/Pasted%20image%2020250925124932.png)

在汇编层面，Hack汇编器有一个惯例：符号变量[从RAM[16]开始分配 ](../../../../机器语言/Branching、Variables%20and%20Iteration.md#^74931a)，依次映射到`RAM[17]`、`RAM[18]`......

一般来说，程序中静态变量数量很少，可能只有几个，所以它们占用的RAM地址都集中在`RAM[16]`开始的一小块区域。而Hack的stack一般是从`RAM[256]`开始，所以`RAM[16] ~ RAM[255]`就在栈之外，这块RAM不被stack覆盖，所以静态变量的值在整个程序运行期间都不会被覆盖或丢失。

所有的VM函数访问静态变量时，都是访问同一块RAM区域，这就实现了“内存共享”。

![](../../../../../../img/Pasted%20image%2020250925140616.png)

![](../../../../../../img/Pasted%20image%2020250925140805.png)

值得一提的是，在实现虚拟机的其他内存段（local, argument, this, that 等）时，设计方法不依赖 Hack 平台。因为每台计算机都有内存和栈，所以这些内存段在Hack上的实现方法同样可以作用于其他电脑上。
但在实现`static`变量时，我们利用了Hack汇编器的特殊规则：符号变量从`RAM[16]`开始映射。这种实现是依赖Hack平台的，若想要在其他电脑上实现`static`变量，本文中所用的方法则不适用，需要另寻他法。


#### temp内存段

下一个要讨论的片段是`temp`段。

为什么我们需要`temp`？当编译器将Jack程序转换为VM code时，有时需要用一些临时变量来存放中间结果。因此，我们为临时变量专门划出了一个大小为 8 的内存段，命名为 `temp`，在需要时用它来存放和提供这些临时变量。

![](../../../../../../img/Pasted%20image%2020250925155233.png)

所以我们决定将该段分配到RAM位置5到12上。当执行`pop`或`push`命令时，显然我们会用到这个基址`5`。与上面的内存段同理，唯一不同的是现在的基址是`5`

![](../../../../../../img/Pasted%20image%2020250925155910.png)


#### pointer内存段

关于`pointer`这个内存段，可能其意义现在来看会有点模糊。因为在开始编写编译器之前，很难真正理解我们为什么需要它，而编译器是后面我们将在课程中完成的事情。所以，现在我们先将`pointer`段解释为某种几乎是任意的游戏规则。那么，这个`pointer`段来自哪里？当编译器翻译一个方法时， 它必须记住`this`段和`that`段的基本地址（`this` 和 `that` 段分别代表当前对象和方法可能操作的数组）。所以我们决定==将`this`段和`that`段的基本地址存储在`pointer`段中。==

![](../../../../../../img/Pasted%20image%2020250925161441.png)

`pointer`段的特点为：
- **大小固定**：只有两个条目，编号 0 和 1。
    - `pointer 0` → `this` 基址
    - `pointer 1` → `that` 基址
- **访问受限**：只能用 `push pointer 0/1` 或 `pop pointer 0/1`，其他索引在 pointer 段中是无效的。
- **作用**：通过修改 pointer 段里的值，VM 可以操作当前对象或数组的位置，从而实现对 `this` 和 `that` 的访问。
- 
![](../../../../../../img/Pasted%20image%2020250925162635.png)

目前，我们已经实现了前两类commands，接着我们将继续探讨剩下两类commands。

![](../../../../../../img/Pasted%20image%2020250925162841.png)
