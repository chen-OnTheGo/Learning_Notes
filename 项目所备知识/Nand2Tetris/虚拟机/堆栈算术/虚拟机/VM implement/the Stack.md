
上一节我们学习了虚拟机的抽象概念，这一节我们从stack开始，描述这些是如何实现的。

![](../../../../../../img/Pasted%20image%2020250922165839.png)

我们需要实现上图的内容，该怎么做？
首先我们需要拿到这四个内存段（实际上有八个），接着将它们映射到可供我们使用的单个RAM上，再进行操作。

在虚拟机中，每个内存段都是逻辑上的抽象，而真实的计算机只有一块联系(连续？)的RAM。要在真实硬件上实现这些命令，就必须先为每个内存段在实际RAM中分配起始位置，并记录这些起始位置，以便知道每个段的内容存放在哪里。

然后，当执行虚拟机的`push`或`pop`命令时，就不能直接操作虚拟机的逻辑段，而是需要根据映射关系，把操作转换成对实际RAM地址的读写。也就是说，虚拟机的命令要被翻译成具体的内存访问操作，这样才能在真实硬件上执行。

![](../../../../../../img/Pasted%20image%2020250922193540.png)

这里先引入指针的概念，在图中，`p` 表示一个存储了内存地址的变量，也就是一个“地址值”；而 `*p` 则表示取出 `p` 所指向的那个内存地址中存放的实际内容。`*p`就是间接寻址的一种操作。

![](../../../../../../img/Pasted%20image%2020250922194910.png)

接下来我们将探讨如何在真实的计算机上实现stack，举个例子：

![](../../../../../../img/Pasted%20image%2020250922195635.png)
（push 17，则会得到不同的stack状态）

接下来展示如何将这两种状态映射到物理内存上。

首先我们将做两个重要假设：
- stack pointer（指向栈顶的指针`SP`）将存储在`RAM[0]`中。
- 整个stack的数据区域从RAM的地址`256`开始存放。

![](../../../../../../img/Pasted%20image%2020250922200231.png)

按照上面的假设，前面例子中的抽象stack里面有两个值：12和5，那么在物理RAM中，它们就会被依次存放在从地址256开始的位置上：

![](../../../../../../img/Pasted%20image%2020250922201213.png)

由于stack pointer始终指向下一个可用位置（栈顶），所以放入两个数字后，`SP`中包含数字`258`。

再从栈顶放入数字`17`，则表示将数字`17`放入`RAM[258]`中，接着，`SP`向前移动一个位置，现在`SP`中存放的值为`259`：

![](../../../../../../img/Pasted%20image%2020250922202117.png)

用汇编语言表示如下：
```
*SP = 17
SP++
```
（其含义是，前往`SP`指向的地址并在那放入数字`17`，然后再增加`SP`指向的地址，这样`SP`就相当于向前移动一个位置）

用Hack语言表示如下：
```
@17    // D=17
D=A
@SP    // *SP=D
A=M
M=D

@SP    // SP++
M=M+1
```

其中，VM translator就负责把VM code翻译成对应的Assembly code，这样计算机才能执行，过程如下：

![](../../../../../../img/Pasted%20image%2020250922213808.png)

目前，我们只实现了一个命令`push constant i`，在下一个单元中，我们将从抽象的角度讨论其他的命令。接着，我们下一节将讨论是如何让它们发挥作用的。