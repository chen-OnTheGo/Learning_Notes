

Nand2tetris Part2最终将实现一个类似于Java或python的高级编程语言，名为Jack。若要使Jack在计算机上正常运行，我们需要一个编译器，将Jack语言翻译成机器语言。

但有个问题是，世界上有很多不同类型的计算机，不同计算机可能有不同的硬件架构，不同硬件架构使用不同的机器语言（比如x86、ARM、RISC-V）。但我们希望我们的程序能在许多不同的平台上运行，例如，在笔记本电脑、台式机、平板电脑等设备。
因此，仅编写一个编译器是不够的，或许我们必须开发许多编译器，使得每个不同的处理器都对应一个编译器。

![](../../../../../img/Pasted%20image%2020250917165954.png)

作为开发者，就需要为每个平台都生成一个版本，这样一来，就需要维护多个版本的程序，既麻烦又容易出错。为了解决这个问题，人们提出了"Write Once, Run Anywhere." 或者说"Write Once, Fix Anywhere." 的口号，意思是，程序不需要为每个平台都单独写，而是编写一次后，就能在多个平台上运行。

Java就是这种思想的典序代表。Java并不是直接被编译为机器语言，而是采用了一种叫两层编译的东西。在第一层中（也叫顶层），Java编译器（javac）把源代码编译成字节码（Bytecode / VM code），这个字节码是专门为**虚拟机**设计的一套抽象指令集，并不是直接能跑在真实硬件上的机器语言。（这里的虚拟机相当于一台虚构的计算机） ^d56486

接着，若我们想真正执行这个字节码，就必须再将其进一步翻译成机器语言。因此，我们需要编译过程的第二层（也叫底层），在该层中JVM实现w负责**把字节码翻译成目标机器的机器语言** 。
这里的JVM本质上是一个程序，它能运行在真实的硬件上，把字节码转换成机器语言并执行。（每个平台都有相应的JVM实现）

![](../../../../../img/Pasted%20image%2020250917213303.png)

由于顶层和底层之间的转换差距很大，通过引入中间级别（VM code），我们将这个非常复杂的过程分成了两个独立的子流程：
- Java编译器只需要生成一种字节码
- JVM实现则负责把字节码翻译成具体硬件的机器语言

也就把“大问题”拆成了两个“小问题”—— 编译器和虚拟机转换器，更容易实现和维护，也方便跨平台。

但看到这我有个问题，这种两层编译思想也需要在每个不同的平台实现不同的JVM，**难道不就是把“实现多个不同的编译器”变成的“实现多个不同的JVM”了吗？** 谈何“优化”？

问了问ChatGpt，解释说：
确实每个平台有一个对应的JVM实现。但如果是每个平台都构建一个编译器，这些==编译器都必须理解Java语法、语义、类型检查、异常处理、垃圾回收等语言特性，每增加一个平台，就需要实现一整套编译器，这是一整套复杂系统==（也就是说，编译器很复杂，要处理语言本身的规则、优化、错误检查，每个平台都重复实现这些逻辑，工作量大）。每次Java语言更新，还要修改这些编译器，项目维护成本高。
但引入JVM后，首先通过javac将程序翻译为字节码，这里的字节码是统一的、平台无关的中间语言。接着每个平台只需要实现一个JVM负责把字节码翻译成机器码并执行，即==每个平台的JVM只需要关注如何将统一的字节码转换成机器指令，不需要再理解完整的Java语言语法和语义。==javac升级或改进时，就只改一份编译器，JVM升级也只影响运行层，与语言本身逻辑分离，这就便于优化和升级。
这里有个生动形象的比喻：

![](../../../../../img/Pasted%20image%2020250918163329.png)
JVM 的优势不是减少数量（确实每个平台仍需 JVM），而是 **降低每个平台的实现复杂度**，把语言实现和平台实现分离，这样维护和升级都更简单。

Java 的这种两层编译思想不是独创，而是对已有技术的延续和实践，这种中间代码+虚拟机的方式其实有几十年甚至近百年的历史渊源。

Jack语言就是一种类似于Java的高级语言，而在本课程中则需要实现在两个不同的平台上执行Jack程序，一个平台是我们自己的电脑，另一个平台则是在该课程Part1中构建的Hack硬件。
我们需要做的事情与Java所做的事情非常相似，我们将编写一个编译器，将Jack程序编译成字节码，然后该课程将为我们的电脑配备一个叫做VM模拟器的软件，它知道如何获取VM程序，然后在我们的计算机上执行它。同时，我们还将编写一个虚拟机转换器，它接受VM code并将其翻译成Hack平台的机器语言。

![](../../../../../img/Pasted%20image%2020250917221607.png)

值得提醒的是，虚拟机是一个抽象的概念，其本质上是虚构出来的，用来模拟计算机的运行环境，属于虚拟化（virtualization）的范畴。
虚拟化是计算机科学理论和实践中最重要的思想之一，没有虚拟化，就没有云计算、通信网络、现代编程语言。
- 云计算是通过虚拟化多个服务器实例来运行不同任务
- 通信网络的协议栈本质上是虚拟化不同层次的通信机制
- 现代编程语言很多通过虚拟机/抽象机屏蔽硬件差异

特别有意思的是，差不多在90年前，图灵写了一篇开创性的论文，他在论文中描述了一台抽象的可以执行计算程序的计算机，他将其称作"**Universal Machine**"（现在被称作**Universal Turing Machine**）。该计算机可以“模拟”任意一种图灵机，只要把某台图灵机的规则作为数据写成输入，Universal Machine就能按照那个规则工作。
这里的Universal Turing Machine的概念就是，一台机器可以模拟任何其他机器的操作，更进一步可以执行并理解另一台机器的程序，也就是说，==程序本身也可以作为数据来处理==。

人类能够思考自己的思维，可以用思维去分析、修改和控制思维过程。而在计算机科学中，这个思想被抽象成**元计算**（**Meta-Computing**）—— 程序可以操作程序本身。

![](../../../../../img/Pasted%20image%2020250918193127.png)

图灵的这种思想将计算机科学提升到了一个全新的复杂程度。我们可以编写程序来分析其他程序，运行其他程序，以不同的方式管理它们。

以下是本课程的宏图：

![](../../../../../img/Pasted%20image%2020250918193907.png)


其实通过本节课，感触非常深刻的是，学计算机一定要去了解计算机的发展史。计算机是如何发展到今天的，其中很多思想都非常有趣，会让你忍不住惊叹这种思想的巧妙