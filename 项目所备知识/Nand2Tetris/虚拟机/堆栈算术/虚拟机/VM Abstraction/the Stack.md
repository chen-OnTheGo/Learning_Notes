
在本单元内容中，我们将开始探索VM Abstraction，本节将从这个VM Architecture中最重要的元素开始，即Stack（堆栈）。

先看整个过程，我们正在开发[两层编译流程](../预览.md)，此过程的核心是操作[VM code](../预览.md#^d56486)的虚拟机。现在，让我们假设我们能自由设计这种VM语言，这正是翻译过程的中间步骤。
![](../../../../../../img/Pasted%20image%2020250918202054.png)

在设计虚拟机语言时，需要在两种相互矛盾的目标之间找到一个平衡：一方面希望虚拟机语言够“高层”，这样它与高级语言之间的差距小，翻译成虚拟机代码时相对容易，虚拟机编译器可以写得简单、优雅；另一方面又希望虚拟机语言够“低层”，与最终目标机器语言之间保持一定的距离，使得虚拟机代码容易映射到硬件上，同时虚拟机的实现也能保持简洁、高效。为了兼顾这两者，计算机科学多年的研究和实践表明，在这两个目标之间取得非常好的一个平衡的一种架构叫做***Stack Machine*** （堆栈机器）。堆栈机器是一种抽象概念，它由一个架构、一个操作堆栈以及一组操作指令组成，通过这种设计，虚拟机语言既能保持适当的抽象层次以简化翻译，又能紧密贴近底层，使虚拟机实现和最终机器码的生成都相对简单优雅。
![](../../../../../../img/Pasted%20image%2020250918202924.png)

为什么选择堆栈？

因为其能够保持这种平衡，主要是因为它天然具备**简洁而通用的抽象特性**，既能服务于高级语言，又能方便映射到底层机器。堆栈的特点在于：所有运算都是通过**入栈（push）和出栈（pop）** 操作完成，==操作数从栈顶取，结果压回栈顶==，这种模式非常直接，不需要复杂的寄存器管理或寻址方式；对于高级语言来说，几乎所有的算术运算、函数调用和条件分支都能通过一系列简单的堆栈操作来表达，保持了对高级语言的抽象能力；对于底层实现来说，栈操作很容易映射到各种机器指令上，因为几乎所有平台都能实现类似的栈操作或者寄存器模拟，编写底层虚拟机实现的复杂度较低。换句话说，堆栈既能提供足够的抽象，使高级语言到虚拟机的翻译简单，又能提供清晰直接的执行模型，使虚拟机到目标机器的映射高效易管理，从而在“高层易翻译”和“低层易实现”之间取得了自然的平衡。

下面是对栈的介绍（由于比较基础，就简单介绍一下）

![](../../../../../../img/Pasted%20image%2020250918203039.png)

为了管理堆栈，我们使用一个**堆栈指针（stack pointer）**，它指向下一个将要被压入堆栈的位置。这个堆栈通常存在于一个更大的虚拟机环境中，这个环境还包含了其他内存段，用来存放变量或数据，这些内存段可以类比为课程中构建的 RAM，本质上就像一个数组，可以通过索引访问其中的值。这样设计让堆栈操作简单直接，同时虚拟机又可以利用常规内存段存储更复杂的数据和状态。
![](../../../../../../img/Pasted%20image%2020250918203451.png)

下面是一些基本的操作：
![](../../../../../../img/Pasted%20image%2020250918203559.png)

首先会pop出操作数，然后执行`add`等指令，接着再将得到的结果push回栈中。
但现在有个问题是，类似于`add`、`neg`、`eq`这些指令是从哪里来的？简单的说，它们来自编译器。如下图所示：

![](../../../../../../img/Pasted%20image%2020250918204118.png)

编译器将类似于`x = 17 + 19`这样的高级语句转换为右侧的lower-level语句，其中就包括这些指令。

高级语言只是人类设计出来的一种抽象描述方式，本身不能直接运行，需要翻译成更接近机器的形式。虚拟机的堆栈机就是作为中间层出现的，但它本身也不是硬件，而是一个由程序实现的抽象，我们需要去实现它才能真正运行高级语言翻译过来的代码。这也就是为什么学习虚拟机很重要：它既是编译过程中的桥梁，也是需要我们具体实现的目标。

虚拟机的核心是一个堆栈机，它的运行完全依赖四类指令：**算术逻辑命令**（比如加减、比较大小）、**内存段命令**（比如 push、pop，用来和不同的内存区域交互）、**分支命令**（比如跳转、条件判断）、以及**函数命令**（比如函数调用和返回）。这样一来，虚拟机提供了一套精简而强大的抽象语言，既能表达高级语言的逻辑，又能比较容易地翻译成底层的机器语言。

下面举例两个执行过程：
![](../../../../../../img/Pasted%20image%2020250918204854.png)

![](../../../../../../img/Pasted%20image%2020250918204936.png)
图中的右侧则是左侧的代码执行的步骤。

以下是我们上述例子中所用过的命令，包括三个算术命令、三个逻辑比较命令、三个经典的逻辑连接器：
![](../../../../../../img/Pasted%20image%2020250918205055.png)

可以知道很有趣的一点是： **任何算术或逻辑表达式（比如加减乘除、比较大小、逻辑与或非）都可以通过一系列针对堆栈的操作来表示并计算出来。**

在堆栈机里，没有像寄存器那样随意存取的结构，你只能把数据压入堆栈（push）、从堆栈取出（pop），然后对栈顶的元素进行操作。所以无论多复杂的表达式，都可以分解成一系列“往栈里放数据 → 对栈顶两个数做运算 → 把结果再放回栈顶”的步骤。

为什么选择堆栈作为核心数据结构？
![](../../../../../../img/Pasted%20image%2020250918205752.png)

在下一个模块中，我们将讨论[Memory Segments(内存段)](Memory%20Segments(内存段).md)。