
在本节中，我们将讨论内存段（Memory Segments）和内存段命令（Memory Segments Command）。

我们从一段Jack高级语言代码来看：

![](../../../../../../img/Pasted%20image%2020250919213202.png)

执行这部分代码时，编译器将其转换成VM code，如下图所示：
![](../../../../../../img/Pasted%20image%2020250919213305.png)

如果这样转换的话，我们会发现，随着代码被翻译成VM code的过程中，我们丢失了一些信息。从高级编程语言的角度来看，不同的变量有不同的角色（或者说类型），例如，代码中的`s1`是静态变量，`c`是局部变量，而`y`则是个参数。如果我们按照上图中的方法来翻译这段代码，则无法表达出这些信息。这些信息对编译器和运行时都很重要，它决定了==变量存储在哪里、作用域多大、生命周期多久==。因此，==我们需要一些机制来记录不同变量在程序中的不同作用。==

于是，我们通过引入Memory Segments的概念来做到这一点，这也是我们虚拟机抽象的一部分。

![](../../../../../../img/Pasted%20image%2020250919214104.png)

我们的 Stack Machine 配备了几个 Memory Segments（如上图所示），其名称包括`argument`（参数）、`local`、`static`等等，一旦我们有了这些 Segments，编译器就能将高级变量映射到这些 Segments（分段）上。

对于上文举的例子，我们将得到这个特定的情况：
![](../../../../../../img/Pasted%20image%2020250919214239.png)

引入了Memory Segments后，我们就可以将刚才遗漏的信息通过代码表现出来了，修改后的VM code如下图：
![](../../../../../../img/Pasted%20image%2020250919214424.png)

可以看到，一旦用这种方式使用Segments，我们就能在虚拟机的抽象模型中保留这些变量的角色语义。
但，有趣的事情发生了（教授是这样描述的），我们在这个过程中丢失了变量名这个信息。

事实上，VM抽象无法识别符号化的变量名，正如我们看到的那样，所有变量都被对Memory Segments的引用所取代。（顺便说一句，本课程的虚拟机是按照JVM来建模的，并且JVM也没有符号变量，仅引用了Symbolic Memory Segments）。

现在，我们没有与单个内存流进行交互，而是与几个不同的内存段进行交互，我们还添加了一个称为`contant`（常量）的片段，它实际上是一个虚拟的片段，因为它只包含了数字。

其Memory Segments Command如下：
![](../../../../../../img/Pasted%20image%2020250919215151.png)

你可能会问，既然`constant`中的每个片段的值与索引值相同，为什么不能把`push constant 17`写成`push 17`？其实，是为了与其他片段引用的语法保持一致，即`push/pop segment i`。

实际上，我们有的不止四个内存段，而是有八个：
`local`、`argument`、`this`、`that`、`constant`、`static`、`pointer`、`temp`。

为什么要细分这么多内存段？别忘了，这些内存段的分类来自于高级面向对象语言的世界，有静态变量、局部变量、参数变量，有一个方法正在处理的当前对象，这个对象也是一个变量包。也就是说，**内存段的细分是为了映射高级语言的语义，让虚拟机能正确执行来自不同作用域的变量操作**。

![](../../../../../../img/Pasted%20image%2020250919220233.png)

一旦进入了 **VM 层（虚拟机的抽象屏障内）**，这些内存段其实都被当作“统一的存储区域”来操作了。换句话说，不管是局部变量还是静态变量，它们的操作方式在 VM 里是一样的：你只需要用一条命令，比如：
```
push segment i
```

==就能把 `segment` 段里第 `i` 个元素的值压入栈。==这里的 `segment` 可以是八个段之一，而 `i` 就是一个非负整数索引。
==对应的 `pop segment i` 则会把栈顶的值弹出并存入 `segment[i]`。==
唯一的例外是 **constant 段**，因为常量本质上只是一个立即数，不存在可以存储的“位置”，所以它只支持 `push constant i`（把常量 i 压入栈），而不支持 `pop constant i`（因为没地方“存”常量）。

在下图的情况下如何操作才能实现`let static 2 = argument 1` ？
![](../../../../../../img/Pasted%20image%2020250919220643.png)

通过操作：
```
push argument 1
pop static 2
```
先将`argument 1`中的值压入栈中，然后将栈顶的值（`argument 1`）弹出，存入`static 2`中。

得到以下结果：
![](../../../../../../img/Pasted%20image%2020250919220819.png)

整个过程中，我们从stack中添加了一些东西，又拿走了一些东西。在运行结束后，stack完好无损，相较之前没有变化。操作的结果是，我们将一些内容从一个Memory Segment（`argument`）中转移到另一个Memory Segment（`static`）中。在本课程的VM抽象中，这将是将值从一个Segment移动到另一个Segment的唯一方法。

下一节，我们将继续讨论如何实现这些命令并运行它们。