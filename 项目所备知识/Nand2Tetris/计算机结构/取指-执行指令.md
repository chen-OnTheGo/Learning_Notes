
在本节中，我们将具体研究计算机一个接一个地执行指令是如何完成的。

这很简单，首先需要获取需要执行的指令，然后直接执行它，然后再repeat。而这也是CPU唯一能做的事：
- `Fetch`（获取） an Instruction from the Program memory.
- `Execute`（执行） it.


### Fetching

计算机将如何获得下一条需要执行的指令，或者说，下一条指令在哪里？由[上节内容](冯%20·%20诺伊曼结构.md#^7b3d6d)可知，它在 `Program Memory`（程序存储器）中。因此，我们需要将下一条指令的地址（接下来要执行的指令的地址）放到 `Program Memory` 中，然后读取 `Memory` 中的内容，就可以得到我们需要执行的指令代码了。

下一条指令通常是挨着上一条指令的，例如，我们执行完8号指令后通常该执行9号指令。有时又会执行 `jump` 指令跳到另一个指令去。

那么，我们如何将下一条指令的地址放入Program Memory呢？事实上，为了记住当前要执行的指令地址，计算机会使用一个专门的寄存器，叫做**程序计数器**（Program Counter, ***PC***）

![](../../../img/Pasted%20image%2020250810102639.png)

`PC` 中存放了指令地址，若按顺序执行，每执行完一条指令， `PC` 会自动加1；如果有jump需要跳转，`PC` 则会直接加载目标地址。

程序计数器就是计算机的“指令位置指针”，负责告诉 CPU “接下来去程序内存的哪里取指令”。

因此，取指过程大概为：
- PC 里保存着**下一条指令的地址**。
- 这个地址会被送到**Program Memory**的**地址输入端**。
- Program Memory在收到地址后，会在它的**输出端口**放出这个地址对应的**机器指令**（Instruction Code）。
- 这条指令就是 CPU 接下来要执行的操作。

现在，我们有了指令，接下来该执行它。


### Executing

机器指令本身包含了我们现在要做的事情的所有细节，例如：
- 应该做什么运算
- 操作的是哪个寄存器或哪块内存
- 是否需要跳转到别的指令执行
这些细节是在 **取指周期（fetch cycle）** 时，从指令中获得的。

所有这些信息都以某种方式编码在我们得到的指令中。通常，它的编码方式很简单，所以基本上指令的比特控制计算机的各个部分。所有执行当前的指令相当于从当前指令中提取位，再根据其信息决定执行什么。

从硬件的角度来看，我们从Memory中 `fetch` 得到一条指令后，这条指令会进入CPU的控制总线中，而这个控制总线基本上控制着一切，例如：它会告诉ALU要计算什么，以及告诉data pieces（数据片段）来自哪里（是来自哪个寄存器还是哪个data memory）等等。

总的来说，我们通过从指令存储器里把下一条要执行的指令取出，基本上可以准确地知道系统的每个部分在执行周期中现在要做什么。
还有很多细节是如何实现的，这里就不讲述了。

相反，我想向后退一步，看看到目前为止我已经掩盖过的某个问题，那就是我们在获取周期和执行周期之间其实存在冲突。


#### 冲突

我们以及知道的是，program和data都驻留在Mempry中。在取指周期中，基本上我们需要通过PC的地址来访问程序存储器中的下一条指令，然后得到指令的输出。

但是，在执行周期中，我们需要访问的数据也驻留在Memory中。因此，我们可能需要访问**数据内存**（RAM）里的某个数据，这与给我们指令的程序片段无关。

如果我们只有一个Memory，就会发生冲突——内存的**地址输入端**一次只能接收一个地址，但我们需要同时接收两种的地址，那么在某个时刻，它应该接收**指令的地址**还是**数据的地址**？  
这就是**取指—执行冲突**（也叫**结构冲突**）。

![](../../../img/Pasted%20image%2020250810111538.png)

如何解决？
通常的解决方式是一个接一个地执行，也就是 **顺序访问**。如何实现？

用`MUX`（多路复用器）在不同阶段切换内存地址输入：
- 取指阶段-> `MUX` 选择 **PC 的值**（指令地址）。
- 执行阶段 -> MUX 选择 **需要访问数据地址**（由指令决定）。

当然内存的输出将进入两个地方：
- **Fetch/Execute Bit**：表示内存输出的内容被送到指令获取和执行单元，也就是 CPU 里的“指令位部分”（指令的二进制位被取出，用于后续解码和执行）。
- **Control bus**：表示内存输出的指令内容被用来产生控制信号，通过控制总线控制整个系统的各个部件（比如 ALU、寄存器、内存等）的操作。

![](../../../img/Pasted%20image%2020250810112951.png)

那么我们如何同时做这两个呢？需要注意的是，一般从提取周期中得到要用于执行周期的指令。

通常的做法是，当计算机处于“读取周期”（fetch cycle）时，CPU 会将下一条指令的地址送入程序存储器（内存），从那里读取出指令，然后将这条指令存放到**指令寄存器**里。这个指令寄存器保存的就是当前正在执行的指令。

接着，在“执行周期”（execute cycle）中，CPU 会根据指令寄存器中的指令，使用数据存储器和其他硬件执行指令规定的操作。

但有一种优化方法，就是把内存分成两个独立的部分：

- 一个专门用来存储数据（数据存储器）
- 另一个专门用来存储程序指令（程序存储器）

这两个内存单元各自有独立的地址空间，避免了在取指令和读写数据时地址上的冲突。每个单元都有自己的地址，我们就不用担心他们之间的转换了。

这种设计叫做**哈佛架构**（Harvard Architecture）。虽然哈佛架构和冯·诺依曼架构（Von Neumann Architecture）不同，但在某些系统里，由于其简单性，它被视为**冯·诺依曼架构的变体**，因为它简化了内存访问过程。

![](../../../img/Pasted%20image%2020250810114104.png)

我们要在下一个单元中专门谈论我们的 HACK 计算机。以及它究竟是如何建造的。