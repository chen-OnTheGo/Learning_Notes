
the Central Processing Unit（中央处理器），也叫CPU，是每种计算机硬件架构的核心。

![](../../../img/Pasted%20image%2020250810161641.png)

它是计算机的中心，因为这是机器的所有计算发生的地方，也是“控制之地”，是决定接下来应该获取和执行哪条指令的地方。

![](../../../img/Pasted%20image%2020250810161723.png)

在本节中，我们将讨论Hack CPU的规格以及我们如何构建它。

像往常一样，我们先将Hack CPU抽象成一个黑匣子（它是一个16位的处理器，就像整台计算机一样），这个黑匣子可以做两种事。

第一件事是，**给定一条Hack语言编写的指令，它就会执行这条指令**。
在我看来，这是一件很神奇的事。因为在此之前，当我们编写程序时，程序存在于一张纸上，它们是完全静态的，并且只是一堆符号，一堆描述了程序员想要实现某件事的幻想。但是现在，我们将这堆符号放到一台机器里面，它们就变成了现实，也许变成了你可以听的音乐，也许变成了一些机票预订系统等等。而其中发挥主要作用的就是CPU，它采用了这个程序恢复并将其变为了显示。

第二件事就是，在执行当前指令的过程中，CPU还会以某种方式弄清楚当前正在运行的程序中**接下来应该执行哪条指令**。

以上则是CPU的抽象概念，接下来我们讨论该设备的更详细的规则。



我们首先需要知道的是，CPU不是单独运行的，它与计算机内部的其他设备相连。特别是在这特殊的Hack架构中，CPU既连接到 `Instruction Memory` ，又连接到 `Data Memory` （如上图所示）。考虑到这点，以下是Hack CPU的输入和输出连接：

![](../../../img/Pasted%20image%2020250810164236.png)

我们有三个不同的数据来源，分别是从 `Data Memory` 、 `Instruction Memory` 、`the user` 三个地方传递过来的，这三种数据分别通过CPU芯片的 `inM` 、 `instruction`、`reset` 三个输入口输入。
首先，有 16 位数据值，即当前选定的 `Data Memory` 中的寄存器的值。这是 CPU 要运行的值。现在，我们到底想让 CPU 做什么？我们决定称之为 `instruction` 的下一个输入，这是一个非常明智的名字，它描述了一个16位的输入，即所选 `Instruction Memory` 中的寄存器的值。
请记住，在任何给定的时间点，指令存储器中总会有一个选定的寄存器，而数据存储器中总会有一个选定的存储器寄存器。所以总是有东西进入 CPU。
第三个输入，我们决定称之为 `reset` ，是一个一位输入，我将在本节的后面讨论。

接下来是输出。

![](../../../img/Pasted%20image%2020250810170307.png)

首先，如果 ALU 想要向`Data Memory`写入一些东西，它必须指定三个不同的内容。
第一，**我们想写什么**。它存储在名为 `OutM` 的输出中或通过输出接受。
第二，我们**想把它写在哪里**。我们必须提供一个地址，这是下一个数据输出的工作。
第三个输出是**允许`Data Memory`进行写入操作的负载位**。
此外，还有一个非常重要的输出，我们决定将其命名为`pc`。通过某种魔法，这个输出**保存了下一条指令的地址**，该指令必须在这台计算机的下一个周期中获取和执行。其效果跟程序计数器相似，由此得名。

我们该如何实现这个魔法？下面是构建CPU的方法之一：

![](../../../img/Pasted%20image%2020250810170901.png)

该图跟上图一样，有着三个输入和四个输出。
在这个架构中，我们有许多标有符号`c` 的标签，我们用它来表示 **control bits（控制位）** 进入不同芯片中的不同位置。为了使所有这些芯片协同工作，CPU的设计者必须确保不同的位、不同的控制位到达正确的位置，而这些不同的“位”拼在一起将使CPU做它应该做的事情。

像上图中的 `Mux16` 、`ALU` 、`PC` 等这些芯片已经在之前的Project中实现了，现在只需要将这些芯片连接起来。

我们必须描述一下这个架构的实际作用。有趣的是，我们把这座建筑当作管弦乐团来看待。一个共同合作的管弦乐团，用许多不同的乐器来创作一些很棒的交响曲，而交响曲就是当前程序的执行。
就像普通的管弦乐团一样，它可以演奏许多不同的音乐，而当前的程序决定了它实际执行的内容。


我们先将目光聚焦于这一部分：
![](../../../img/Pasted%20image%2020250810173000.png)

这部分主要由一个 `A register` 和一个多路复用选择器 `Mux16` 组成。

![](../../../img/Pasted%20image%2020250810173105.png)

根据[Hack语言规范](../机器语言/Hack语言规范.md)，我们知道，输入的指令共分为两种—— `A-instruction` 和 `C-instruction`，也知道我们是通过指令的第一位来区分这两种指令，如何来处理这两种指令？

对于指令A，CPU先将其解码成 `op-code`(操作码) 和剩余15位值，然后将这15位值存于A register中，再输出。

![](../../../img/Pasted%20image%2020250810173548.png)

对于指令C，CPU则先将其解码成 `op-code` 、`ALU control bits` 、`destination load bits`、`jump bits` 这[四个部分](../机器语言/Hack语言规范.md#^43d39e)，然后将用于启动和操作计算机架构中的相应部分。

从图中可知，A寄存器的输入值可能来源于 `instruction` ，也可能来源于`ALU output` ，我们需要控制住在什么情况下输入哪一种。因此，当输入指令为A指令（操作码为0）时，我们希望寄存器A的输入来自于该指令；当输入指令为C指令（操作码为1）时，我们希望寄存器A的输入来自于ALU。
所以，该部分的工作是检查传入指令的操作码，然后决定A寄存器从哪个来源获取。

现在我们扩大聚焦点：
![](../../../img/Pasted%20image%2020250810200225.png)

当我们接收到C指令时，则由指令的**计算位（Computation bits）** （也就是蓝色部分的六位数值）来决定 `ALU` 执行哪种操作。

图中可以看出，`ALU` 的输出连接了三个不同的目的地：`Mux16`、`D register`和芯片之外，相当于相同的ALU输出会去敲三个不同的门，这三个门也不一定会同时打开，需要通过三位**目标位（destination bits）** 来决定哪扇门打开，例如：`000` 表示三扇门都关闭，`111`则表示三扇门都打开，即ALU的结果会传输到这三个地方。

![](../../../img/Pasted%20image%2020250810202024.png)

被圈中的这位输出则用来标注输出值为负数还是零（正数不用标出）。若为负数则为1，若为零则为0。


关于前面所说的对 `reset`的解释，我们可以将计算机看作一个黑匣子并带有一个重置按钮：
![](../../../img/Pasted%20image%2020250810202240.png)

起初这个计算机没有任何动作，当我们按下这个按钮后，计算机**开始运行**，若我们决定**重置计算机**或**重新运行相同的程序**，也可以通过这个按钮来实现。可以这么说，除了别的功能之外，这就是我们想要在 CPU 的控制逻辑中实现的那种行为。

现在我们已经从计算机外部了解了重置按钮的工作原理。让我们回到 CPU 逻辑，探索 CPU 的控制逻辑。

![](../../../img/Pasted%20image%2020250810203531.png)

让我们把注意力放在最后三位上，这三位是`jump bits`，用来决定在什么情况下跳跃或不跳跃。现在CPU将要实现这个功能，该如何实现呢？

故事的主角是一个不起眼的寄存器，叫做 `Program Counter` （程序计数器），也叫`PC`。

通常来说，我们会希望PC做的一件事就是始终发出**必须执行下一条指令的地址**。所以如果我们想启动或重新启动计算机，就必须将PC设置为0（因为我们需要执行程序中的第一条指令），因此PC等于0也是很有意义滴。接着，如果没有出现需要跳跃的情况，也就是三个jump bits都为0时，我们希望PC增加一步，表示按顺序执行。

如果三个jump bits都为1，就表示需要无条件跳转，我们则将PC设置为A—— `PC = A`，为什么？因为在这种情况下，程序员通常会**事先**将目标跳转地址加载到 **A 寄存器**中，以确保跳转能够准确到达指定位置。这样，我们就可以直接取出A寄存器里面的地址，再将该地址设置给PC。

如果是有条件的跳转，我们则必须查看ALU的输出并决定是否应该 `goto`，如果条件为真，则跳转；如果条件为假，则执行PC++。

![](../../../img/Pasted%20image%2020250811155748.png)

以上就是PC在任何计算机中应有的工作方式。我们用伪代码表示一下：

![](../../../img/Pasted%20image%2020250810205354.png)

这里的函数 `f` 仅表示结合 `jump bits` 和 `ALU control outputs` 的情况来决定 `load` 为1还是0，即决定是按顺序执行指令还是跳转。

我们必须明白，这些复杂的设计只是整个计算机架构中的一部分。换句话说，CPU 是目前架构中最复杂且最有趣的组成部分。

在下一个单元，我们将介绍 Hack 计算机的整体架构，随后开始动手实际搭建 CPU 以及整台 Hack 计算机。