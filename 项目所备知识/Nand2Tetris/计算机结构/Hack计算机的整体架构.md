
![](../../../img/Pasted%20image%2020250810210457.png)

上图是Hack 计算机的整体硬件架构，我们可以看到多了一些新的东西——两个输入输出设备：
- 一个显示屏，它使我们能从计算机中获取值，再将其以某种形式展现给人们
- 一个键盘，可以让我们与聚焦进行交互。

再本节中，我们要做的是专注于这三个部分中的每一个，先描述一下它的作用。再思考我们如何才能真正建造它。

我们先从CPU开始，因为他是架构的核心。由于[上一节](CPU（中央处理器）.md)已经描述了CPU的很多细节，这里就不再阐述了。

![](../../../img/Pasted%20image%2020250810211109.png)

- 当CPU收到一条指令时，会根据指令中指定的内容操作CPU内部的寄存器，比如D寄存器和A寄存器。

- 如果该指令是一条A指令 `@x` ，那么在这种情况下，CPU则会取地址码（后15位），即 `x`，再将它们放入A寄存器中。

- 如果指令中包含了对内存（M）的访问（指令右侧包含了助记符 `M`），CPU会通过数据存储器接口读取或写入相应的内存地址和值（通过接口 `inM`）。

- 如果指令左侧包含了助记符 `M`作为the destination of the operation，其输出值将被存在 `Memory` 中。
![](../../../img/Pasted%20image%2020250810212629.png)

为了写入内存，CPU 必须同时提供三种信息：

1. **要存储的值** → ALU 计算出来的结果。
2. **地址** → 存到内存的哪个位置，这个地址在 Hack 架构里是由 `A` 寄存器提供。
3. **控制位** → 一个信号（write enable），告诉内存模块 “现在允许写入”。否则内存不会改动。

CPU是如何实现跳转的，我们举个例子：

![](../../../img/Pasted%20image%2020250810212817.png)

意思是，假设A寄存器已经包含地址100，如果`D=D-1` 的结果为0，则跳转到A寄存器中地址为100的地方。流程是这样的：
如果`reset` 为0（用户没有按下重置按钮），CPU 使用跳跃位和 ALU 输出来决定是否应该进行跳转。如果有跳转，PC 将设置为 A 寄存器的值。如果没有跳跃，则会增加 PC，更新后的 PC 值由 CPU 的 `pc` 输出接口发出。如果 reset 等于 1，则表示用户想要重置，然后从头开始重新运行程序，`pc`设置为零。

接下来讨论 `Data Memory`（数据存储器）。


### Data Memory

我们将从三个不同的部分来考虑—— `Data Memory` 、 `Screen` 、 `Keyboard`。

![](../../../img/Pasted%20image%2020250810214843.png)

地址 0 到 16k 用于**存储程序生成和操作的数据**。接下来的 8k 内存用于存储**屏幕内存映射**。如果你想在屏幕上画点东西，你必须操纵这个内存段中的位。最后，存储器中的最后一个寄存器用于反射或告诉我们**键盘上当前正在按下哪个键**。

我们可以通过从三个不同的子芯片来构建内存——标准的RAM芯片、特殊芯片 `Screen` 、特殊芯片 `Keyboard`。（这三个子芯片其实是三个逻辑段，它们在物理上没有分离开，只是在逻辑上是分离的）

![](../../../img/Pasted%20image%2020250810215207.png)


让我们从RAM开始。
在之前的Project中我们已经实现了它，所以现在只需要将其插入即可。需要注意的是，RAM16的输入和输出与整个 `Memory` 芯片的输入和输出相同，因此，不管是谁设计制造了这个芯片，都要保证 **外部接口**（引脚）跟 **内部电路** 正确连接（外部输入的信号（地址、数据、控制信号）必须正确传到芯片内部电路；外部输出的信号（数据输出）必须来自内部的存储阵列）。

下一个部分叫做 `Screen` ，前面的章节已经详细讲过了，下下个部分`Keyboard`也是，这里就不再赘述，请转战[输入输出设备](../机器语言/输入输出设备.md)。

需要提一下的是，在大多数情况下， `Screen` 只是一个普通的RAM芯片，但让人耳目一新的是，它有一个连接的显示单元：

![](../../../img/Pasted%20image%2020250810215943.png)

当我们更改Screen部分中的字节时，相应地屏幕也会刷新，通常每秒刷新会发生好几次。

实现 `Keyboard` 也只需要一个芯片：

![](../../../img/Pasted%20image%2020250811130226.png)

当我们按下某个按键时，[该芯片就会反映出其按下的内容](../机器语言/输入输出设备.md#^f7ee2c)。

![](../../../img/Pasted%20image%2020250811130541.png)

如果是在Hack内存的整体环境中使用键盘，则必须加上基址（？）


### Instruction Memory

接下来我们要实现Hack的指令存储器，我们将使用一种称之为ROM 32K的芯片来实现这个指令存储器：

![](../../../img/Pasted%20image%2020250811132609.png)

假设现在我们的桌子上由这台电脑，在计算机的旁边由一个用Hack机器语言编写的程序。
为了运行这个程序，我们首先要做的就是以某种方式将这个程序加载到计算机中，也就是把程序加载到ROM 32K芯片中，再按下reset按钮，程序就可以开始运行了。以上就是我们需要实现的。

![](../../../img/Pasted%20image%2020250811133000.png)

我们如何才能将静态的、纸上的或者存在于文本文件中的程序加载到电脑里呢？事实证明，有几种方法可以做到这一点。

一种是使用 `plug-and-play ROM chips` （即插即用的ROM芯片）。我们将我们的程序烧录到ROM芯片中，再将该芯片插入电脑，按下reset按键就可以开始运行程序了。如果想运行另一个程序，就需要拿一个另一个新的芯片来进行烧录，然后就是相同的操作。
这与某些游戏机的操作方式非常相似，玩某款游戏则需要插上相应的卡带，如果想换个游戏，就需要插上另一个卡带。

另一个方式就是使用硬件模拟器，也就是我们本单元需要做的。


下图则是我们的ROM 32K芯片：

![](../../../img/Pasted%20image%2020250811133656.png)

输入需要取指的相应地址，该芯片就会输出相应地址中包含的指令。

现在我们终于可以来讨论如何构建整体Hack计算机架构了，我们从CPU开始，并将指令存储器连接到它。

![](../../../img/Pasted%20image%2020250811133901.png)

CPU的`pc` 输出取指地址，输入到ROM32K中，ROM32K再将该地址中的指令输出，输入到CPU的`instruction` 中，即告诉CPU该执行什么指令。

接着再连接上存储单元和输入输出设备：

![](../../../img/Pasted%20image%2020250811134226.png)

我们想写什么，我们想写在哪里，以及 `load bit` ，最后，我们获取内存的输出将其连接回CPU，因为有些指令我们想在内存上进行操作，而不是将在外操作好的结果直接写进内存。

这就是我们的Hack计算机架构，这台计算机的用户在外观上只能看到显示屏、键盘、和一个reset按钮。


下面引用一下Shimon教授的话（翻译可能有误差）：

>当我审视这个架构并反思我们迄今为止所做的一切时，这句话让我想起了美丽意味着什么。
>![](../../../img/Pasted%20image%2020250811134839.png)
>
>我们将美归因于简单的事物，它没有多余的斑点，它恰好回答了它的终点，它与所有事物息息相关，这是许多极端的意思。120年前，拉尔夫·沃尔多·爱默生就是这么说的。
>
>我希望你也同意我的看法，按照这个标准，Hack 电脑很漂亮。它之所以如此美观，原因之一是因为它非常简单。你知道为了构建这个计算机，只要构建了这三个芯片，你所要做的就是写大约三行 HDL 代码，这非常了不起。