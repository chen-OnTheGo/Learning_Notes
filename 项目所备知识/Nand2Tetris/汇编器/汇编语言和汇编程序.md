
上个单元，我们构建了一台可以运行机器语言代码的计算机。前面几个单元，我们都是用机器语言来变成的（并没有真正用二进制代码编程），但计算机能接收的却是其二进制的形式。从机器语言到二进制代码，这个是怎么过渡的？这就需要提到一个软件程序—— `Assembler`。

![](../../../img/Pasted%20image%2020250812112625.png)

如上图，两个单元前的课程我们的重点是左边的汇编语言格式，上个单元我们的视角是右边的机器语言会如何执行。而本单元我们将重点放在中间的“转换”，即这两个是如何实现转换的。

汇编器是什么？它是一个将汇编语言代码（左）翻译成机器语言代码（右）的程序。

需要注意的是，汇编器是一个软件程序，它将一个以左侧格式（即汇编语言）编写的文件作为输入，然后生成另一个以右侧格式（即`0`和`1`）编写的文件，可以直接在计算机上执行。

汇编器基本上是我们每台计算机中的第一个软件层，在汇编器之上，还会有更多复杂的软件（比如编译器、操作系统、应用程序），但汇编器是最靠近硬件的第一级，它能帮助我们理解整个系统从硬件到软件的完整流程。

将汇编器与前面的硬件一起学习，这样我们就能拥有一个完整的画面，就可以理解计算机是如何编程的，理解对计算机进行编程并不意味着只能用 `0` 和 `1` 来编程，而是用汇编语言进行编程。汇编语言仍然是一种非常低级的语言格式，本质上等同于机器语言，但仍然能被人们理解。

![](../../../img/Pasted%20image%2020250812114252.png)

接下来让我们看看汇编器是一个什么样的软件。

原则上，我们只创建了一台可以运行机器语言代码的计算机，所以按理来说我们应该用这台计算机唯一可以执行的语言（机器语言）来编写程序，也就是用`0`和`1`来编写程序，这样也太麻烦了。

幸运的是，现在科技发达，世上已经有了各种各样的电脑，并且能运行高级语言，我们不妨以现在时代做背景，用现成的电脑来写汇编器，在现成的电脑中将汇编语言翻译成Hack计算机能理解的二进制代码，再将翻译后的二进制代码拿给Hack计算机使用。这样也避免了`bootstrapping problem` ——如果你要写汇编器来翻译汇编语言，但汇编器又要先运行在 Hack 计算机上，那就得先用 Hack 的机器语言写出汇编器，很痛苦，所以我们直接用现有电脑和高级语言写汇编器，简单得多。这样，我们就没有这个循环，也不会遇到必须用机器代码编写汇编器的引导问题.

因为这个汇编器是在**一台电脑**上运行，但生成的是给**另一台电脑**（Hack 计算机）用的机器代码，所以它其实就是一种`cross compiler`（交叉编译器）。

汇编程序实际上是一个非常简单的程序，它会执行以下几个步骤，然后一次又一次的重复：

![](../../../img/Pasted%20image%2020250812115455.png)

它先从输入中读取一个汇编语言命令，然后将其分解成几个部分，每个部分都能用我们语言指定的独特方式翻译成二进制形式。然后我们把翻译后的二进制代码拼接起来，这样得到的机器语言代码就直接等同于刚才读取的汇编语言命令，将这个二进制代码输出，然后接着操作下一个汇编语言命令，如此重复。

上面是整个过程的大致描述，现在让我们更仔细地观察一下每个阶段。

我们知道的是，为了程序的可读性，我们往往会在程序中加入空格、换行，或者编写注释，这样，当我们依次读取汇编语言命令的时候就不是一行接着一行这么简单了。那么我们如何读取下一个汇编语言命令呢？唯一的困难是我们需要跳过这些空白和注释，确保读取的是下一个命令的内容。

![](../../../img/Pasted%20image%2020250812120250.png)
如图，假如我们有个汇编语言命令： `Load R1,18`（汇编语言命令的格式将在下节讲），我们猜测这条命令的意思是：取值18并将其放入第一个寄存器中。但这不是重点，我们当务之急是读取该命令并将其放入某种字符串变量中或者某种字符数组中，以便我们后续处理。这基本上就是从输入中逐行读取所涉及的内容。

下一步就是将这串字符分解成几个部分。
当我们查看它是，可以看到这个命令分为三个部分，分别是：`Load`、`R1`、`18`。
此外，还有一个空格和一个逗号，但这两个都不重要，只是一些语法，帮助我们分解和理解所写的内容。

![](../../../img/Pasted%20image%2020250812121245.png)

因此我们将这个原始字符串分成三个子字符串，就得到了不同部分，再将这些部分分别翻译成机器语言，也就是二进制形式。如何翻译？
我们会有一个表，上面记录了不同命令对应的不同的二进制码，照着这个表去翻译就可以了。
![](../../../img/Pasted%20image%2020250812121425.png)

如果遇到了数字，比如上面的“18”，我们就直接将其翻译成它的二进制形式。

现在我们基本上有了输入命令的每个部分的翻译，接下来第三部分就是将这些分开的二进制码以某种方式拼接在一起，通常只是某种串联。但是有时候转换成的二进制码并不能填满机器中的所有可用位，所以我们还需要加如规范定义中的一些其他位来填充，例如其他位被指定为 `0`或`1`。
![](../../../img/Pasted%20image%2020250812122559.png)

我们已经有了需要输出的二进制码，就只需要把它打印到某个文件中即可。
如何打印出来？机器语言的文件格式会有某种规范，**可能**必须是二进制格式，只有字符0和1。

![](../../../img/Pasted%20image%2020250812122840.png)

以上就是汇编器基本操作的描述，现在还有一个问题，那就是处理符号，别忘了，汇编语言为程序员提供的主要服务之一是**不用直接写数字地址（比如 `@123`），而是用符号（symbol）来表示**。我们通常用符号来做两种事：
- 设置 **标签(label)** 用来标记程序某一行的位置，方便跳转（JMP）。例如前面的`(POSITIVE)`。
- **变量名（variable name）**：用来代表内存中的某个位置，而不是直接写硬编码地址。

![](../../../img/Pasted%20image%2020250812140332.png)

我们的汇编人员要做到就是将这些符号替换成相应地址，该如何实现？

和处理命令时相似，我们需要maintain一个表格，里面包含了符号和实际地址之间转换的信息，每次翻译就会到这个表格里去查找，看看用哪个地址来代替这个符号。

![](../../../img/Pasted%20image%2020250812140948.png)

如何maintain这样的表格？如何向其中输入信息，又如何从中查找信息？

举个例子，假如我们的汇编器正在逐个命令读取，遇到了这个命令`Load R1, weight`，这里面有个变量`weight`，如果表中已经记录了该变量的对应地址，我们就只需要在表中查找，但是如果是第一次看见这个变量`weight`，会发生什么？

![](../../../img/Pasted%20image%2020250812141702.png)

我们看了看变量`weight`，再查找Symbol table，发现表格中没有记录该变量的信息。所以，我们需要分配一个新的内存位置来保持这个变量的信息，这是我们汇编器必须做的事情之一。因此，汇编器会找到下一个**可用**的内存位置，分配给这个变量。然后汇编器会把这个变量名和它对应的内存地址存到lable里。以后再遇到相同的变量`weight` ，就可以之间查找Symbol table了。
【分配的规则（比如变量是不是从 RAM 第 16 个地址开始放）由**汇编语言的规范**决定。】

![](../../../img/Pasted%20image%2020250812142655.png)


我们还有另一种符号就是标签label。

![](../../../img/Pasted%20image%2020250812142848.png)

如图，我们有一段代码里面有标签`loop`，当汇编器查看并读取这一行代码时，它能明白`loop`只是一个标签，不是一个要执行的命令。但是当下次想跳转到这个位置时，就需要访问这个位置的地址。所以，即使现在知道这行代码不用执行，但还是需要记住该标签所在位置，以便接下来的代码如果要跳转到这，就可以到表中查找。
![](../../../img/Pasted%20image%2020250812143254.png)

还有一个问题，有时候标签的定义在标签的使用之后（代码从上往下看，先使用标签，再声明标签），这种情况叫***forward reference***（前向引用）。

举个例子：

![](../../../img/Pasted%20image%2020250812143652.png)

在程序中，在标签`cont`声明前，我们需要跳转到`cont`的位置，但是当准备跳转时，发现Symbol table中并没有记录相应的内存地址。有两种办法可以解决：

一种有点复杂的方法是，当运行到`JGT cont`这条指令时，准备跳转，但是发现Symbol table里面没有相应地址，此时就把这个未知标签记录在一个临时的辅助Symbol table里面，然后接着往下读取指令，当遇到该标签的声明时，再回头将其相应地址等信息填入表中。 ^aaa1d4

另一种较为简单的方法是，直接扫描两遍程序。第一遍扫描记录所有标签以及其对应的地址到Symbol table中，第二遍扫描则直接通过查找Symbol table将程序中所有tabels替换成相应地址，生成机器码。

这两种方法都可以使用。

下一节我们将讨论Hack计算机汇编器的不同部分是如何建造的。


