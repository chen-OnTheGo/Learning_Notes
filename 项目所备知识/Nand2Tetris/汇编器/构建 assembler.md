
在本节中，我们将构建一个汇编器。

由上节可知，我们的汇编器就是将`Hack assembly code` 翻译成 `Hack binary code`：

![](../../../img/Pasted%20image%2020250812154840.png)

总的来说，这是一个翻译挑战，我们必须把源语言翻译成目标语言。就如中译英一样，要把中文翻译成英文，首先我们需要知道这两种语言的语法规则，才能将中文分解或解析其语言元素，然后通过观察弄清楚这句中文的语义是什么，再用英语重新表达语义。

值得强调的是，我们必须知道英语的语法规则，才能将分解并翻译好后的语言元素合成目标句子。编译器的工作就类似于这种，但编程语言的编译器的任务会轻松一些，因为编程语言比我们的口语或自然语言简单得多，机器语言会更简单，所以不用担心。

第一步，弄清楚源语言的语法规则，也就是Hack汇编语言的语法规则。在前面已经提过了——[Hack语言规范](../机器语言/Hack语言规范.md)。

Hack汇编语言由A指令、C指令和符号组成。

![](../../../img/Pasted%20image%2020250812155859.png)

![](../../../img/Pasted%20image%2020250812155918.png)

![](../../../img/Pasted%20image%2020250812160012.png)

有了对Hack机器语言的完整描述，应该就能够开发出所需的汇编器了。

比如下面的程序：

![](../../../img/Pasted%20image%2020250812160231.png)

由这个程序可知，其由空白（包括注释）、指令、符号组成，所以，**如果你想写一个汇编器，你必须知道如何处理空白、指令和符号。**

我们由易到难，所以先不考虑有符号的程序，先构建一个处理无符号程序的汇编器。

我们从white space开始，如何处理？下图将white space凸显了出来：

![](../../../img/Pasted%20image%2020250812160802.png)

处理white space的最简单方法，也是最明智的方法，其实也就是Ignore it！所以我们只需要将上图程序中红色的部分都忽略掉，剩下的就只有指令了，于是，我们的挑战简化为翻译具有纯指令的程序：

![](../../../img/Pasted%20image%2020250812161028.png)

可以这么说，这些是A 指令和 C 指令的序列或stream。为了翻译它们，我们必须知道如何将这些指令转换为二进制代码。


### 翻译指令

指令分为A指令和C指令，我们先来讨论翻译A指令。

#### 翻译A指令

前面已经介绍过[A指令](../机器语言/Hack语言规范.md#A指令)的特点：
- Symbolic syntax： `@value`
- Binary syntax：`0valueInBinary`

所以我们要做的，就是将汇编语言形式的A指令的`value`部分的数值由十进制转换成二进制，并在其前面补`0`直到补到15位，再将`@`翻译成 `0`，放在首位，这样就组成了该指令的16位表示形式。

那么C指令呢？

#### 翻译C指令

![](../../../img/Pasted%20image%2020250812163536.png)

这些就是C语言的规则，只需要分别提取指令中的各个部分（一共三个部分）—— `dest` 、`comp`、`jump`。并找到其在Symbol table中对应的二进制码，再以`Binary syntax`的格式组合成就可以了。

例如指令`MD=D+1`，由于C指令的二进制形式的前三位都是1，所以我们先确定出：`111 xxxxxxx xxx xxx`，接着是指令中的`MD`，对应destination bits那个表，找到其对应值为`011`，填入得：`111 xxxxxxx 011 xxx`；接着是指令中的`D+1`，对应comp表中的`a=0`、`011111`，所以就得到了`111 0011111 011 xxx`；由于没有jump部分，所以就对应`no jump`，即`000`。
所以这个例子翻译成二进制码就是 `111 0011111 011 000`。

当把程序翻译完后输出，我们基本上就生成了一个包含两种字符（`0` 和 `1`）的文本文件，然后我们将这个文本文件加载到计算机中，它就会变成真正的`0` 和 `1`。

我们解析指令时，如果是A指令，就将其分成`@`和一个地址值，再翻译；如果是C指令，就将其分成三个字段: `comp`、`dest`、`jump`，然后再翻译。

现在我们已经掌握了构建 翻译无符号程序的汇编器 的思路，为了构建一个通用汇编器，我们需要度过翻译符号的这个关卡。


### 翻译符号

Hack程序中的符号分为三个不同的类别：变量、标签、预定义符号。

![](../../../img/Pasted%20image%2020250812173329.png)

由于前面已经介绍过这三个，这里就简单提几句。
变量可以让程序员避免直接处理复杂的内存地址，专注于程序逻辑，而将地址解析的工作交给汇编器完成。

预定义符号可以理解成值不能改变的变量，也就是高级语言中的常量的意思：

![](../../../img/Pasted%20image%2020250812173350.png)

处理这三种符号的步骤极为相似，大同小异。共同的步骤就是：我们都需要一个叫`Symbol table` 的表格来存储这些符号和其对应的值。且当我们得到该符号对应的值时，需要将其从十进制转为二进制。

不同的是，预定义符号在程序运行前就已经被存在了Symbol table中，因为其毕竟是“常量”，对应值不会因为程序而改变。而变量和标签则是程序运行过程中，第一次遇见时存储在Symbol table中的。

前面也提过[两种处理方法](汇编语言和汇编程序.md#^aaa1d4)，我们采取第二种方式，即两次汇编：

![](../../../img/Pasted%20image%2020250812174058.png)

首先我们初始化一个空表（Symbol table）（用某种数据结构来实现），再将`pre-defined symbols`（预定义符号）和其对应值存在Symbol table中。

然后我们开始第一遍扫描，并用一个计数器记录当前指令的行数（从0开始），当扫描到第一个左括号时，我们将括号里的tabel名取出，此时计数器中的值+1就是这个tabel的对应值，将这对“键值对”存于Symbol table中。

在扫描前，先将`n`的值[设置为16](../机器语言/Branching、Variables%20and%20Iteration.md#^74931a)。接着开始第二遍扫描，对于每条指令，下面是处理的伪代码：
```
if 为A指令:
	if 在Symbol table中找到该symbol的对应值:
		直接利用Symbol table来翻译
	if 没有找到对应值:
		将(symbol, n)加入Symbol table中
		用 n 翻译程序中的symbol的值
		n++
if 为C指令：
	直接根据三个表来完成翻译
将翻译结果写入输出文档
```

