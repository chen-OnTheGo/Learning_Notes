
### 寄存器

Hack中有三个主要的寄存器：
##### A寄存器
- **用途一**：存放地址
    - 比如你写 `@100`，然后 `A` 里就存了 100。
    - 然后 `M=D` 或 `M=1` 时，`M` 指向 A 寄存器里的地址对应的内存位置。
- **用途二**：也可以当作普通寄存器存储数据，但通常用它来指定内存地址。

##### D寄存器
- 专门用来存放数据（Data）
- 可以用来做运算或者临时存储值。
- 比如你从栈里弹出的值放到 D 寄存器，然后再写到内存。

##### M寄存器
- **M 是内存单元**，指向当前 A 寄存器指定的地址。
- `M=D` 就是把 D 寄存器的值写入内存地址 A 指向的地方。


### A指令

该指令用于将A寄存器的值设置为特定值。

![](../../../img/Pasted%20image%2020250805191237.png)


### C指令

![](../../../img/Pasted%20image%2020250805191201.png)

C指令可以用来做三件事：
- compute一个特定的表达式
- 可以将其计算的值存储在某个destination中
- 可以通过计算出的值，来决定跳转并执行存在于程序不同区域的东西

![](../../../img/Pasted%20image%2020250726121024.png)

第一位表示操作码，是用于区分这是A指令（为0）还是C指令（为1）.
第二位和第三位不使用，按照惯例则设为1。
从a到c6为***计算位（Computation bits）*** 表示我想进行什么样的计算操作，**a 位**（第 12 位，紧跟在 111 之后）决定 ALU 的一个输入是来自 A 寄存器还是来自 M（内存），**c1-c6**则是控制 ALU 运算方式（加、减、与、或、取反等），这些控制位稍后会发送到ALU，在ALU中进行相应的计算。
而从d1到d3是目标位（Destination bits），表示指令里指定**结果存放的位置**的位字段。
最后三位则是***跳转控制位（Jump bits）*** 。 ^43d39e


![](../../../img/Pasted%20image%2020250726122753.png)

这是Computation bits 的值与对应操作的表格。如果想执行`D+1` ，则Computation bits每位对应的数值应为`011111` 。


下图则是Destination bits的值与对应操作的表。
![](../../../img/Pasted%20image%2020250726122538.png)


接下来是Jump bits的。
![](../../../img/Pasted%20image%2020250726122643.png)


#### 举例

二进制指令 `1111010101101110` 

其中`a=1` ，`010101` 表示执行`D|M` 操作，`110` 表示结果存放于`AM`中，`110` 则表示`JLE` 。

故，该二进制指令表示 `AM = D|M; JLE` 。

下图则是一个典型的Hack程序的例子：

![](../../../img/Pasted%20image%2020250726141704.png)

当然，这些语言是象征性的助记符，除了 `0` 和 `1`，计算机无法理解其他符号。若要在计算机中运行，还需要将其转换成二进制代码，而这通常由一个叫汇编程序的程序来完成的：

![](../../../img/Pasted%20image%2020250726141831.png)

为了提高语言的可读性，建议在使用寄存器时，用 `Rx` 来代替 `x寄存器` ，如下图所示，其执行效果都是一样的。同时，注意区分大小写。 ^enhanceReadability

![](../../../img/Pasted%20image%2020250806175114.png)

以及分别用 `SCREEN` 和 `KBD` 来代表[屏幕映射内存](输入输出设备.md#输出设备（显示元素）——屏幕) 和 [键盘映射内存](输入输出设备.md#输入设备——键盘) 的基地址。

![](../../../img/Pasted%20image%2020250806222217.png)