### Branching

`Branching(分支)` 是告诉计算机评估某个布尔条件或布尔表达式的基本能力，并根据这个值来决定我们是否要"jump"，并在程序中执行其他部分，或者继续前进，执行程序中的下一条指令。

任何编程语言都有不同的分支机制，例如用Java或Python编写程序时，所谓Branching就是 `if else`、`while` 、 `switch` 等之类的东西。

然而在机器语言中，我们通常只有一个分支设备，叫做 `goto`。

下面就是一个例子：

![](../../../img/Pasted%20image%2020250806223732.png)

如果我们去掉注释和行号，这段代码将很难被理解：
![](../../../img/Pasted%20image%2020250806224122.png)

借用 `Donald Knuth` 的话：

> Instead of imagining that our main task as programmers is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.

这段话强调了编程可读性的重要性。如果我们的程序不能清晰地表达它自己在做什么，那么我们将无法修复和扩展它们。

那么，我们如何来使上面那个程序更具可读性呢？幸运的是，我们在汇编语言中有一个非常好的功能，叫 ***Symbolic references*** （符号引用）。

我们在跳转代码的位置放置一个label，名为 `POSITIVE` 。表示这段代码是可能从程序中的其他代码跳转到这儿来的。

![](../../../img/Pasted%20image%2020250806225334.png)

label会被忽略，就跟注释一样，但对标签的引用就不会被忽略，每个标签的引用都会被该标签声明位置后面的指令的行号所取代。


### Variables

>A variable is an abstraction of a container that contains a name and a value.

`Variable` （变量）是对某种“有名字、可以存储值的容器”的抽象表示。

在更高级的高级语言中， 我们有不同类型的数据，不同类型的变量 ，但是，在较低级别的机器语言中，或者至少在较低级别的本课程的Hack机器语言中，我们只有一种变量类型。我们只需要在16位的值上花心思。

而且，这种abstraction可以通过使用我们数据存储器中的单个寄存器来传送或实现。因此，如果我们想在程序中创建变量，就使用单个寄存器来表示我们的所有变量。

下面是一个例子，要实现翻转（互换值）`RAM[0]` 和 `RAM[1]` :

![](../../../img/Pasted%20image%2020250807000051.png)

`@temp` 是什么意思呢？请注意，这里的`@temp` 和标签引用不同，因为我们没有名为 `temp` 的相应标签。

这里的 `@temp` 相当于我们让计算机前往存储单元，找到一些可用的存储寄存器，假设找到了register n，这里的 `temp` 就相当于 `register n` 的代号，所以 `@temp` 等价于 `@n` 。

![](../../../img/Pasted%20image%2020250806235634.png)

Hack语言设计具有以下两条规定：
- 对没有相应标签声明的符号引用将被视为对变量的引用（与Branching区分开来）
- 变量从RAM的地址`16` 开始分配（例如，如果我们只有一个变量，则其被分配给 `RAM[16]`，若有更多的变量，则会分配给地址17、18......以此类推） ^74931a

修改后的程序明显比之前用实际数字来表示地址时的程序更具可读性。其实还有个好处，就是这个程序是**可重定位代码** 。也就是说，我们可以把这个变量加载到内存的任何地址，而不是必须从地址0开始，只要我知道这个变量所用的基地址，我就可以在内存的任何地方运行它。这一点很重要，因为我们平时使用电脑时，经常是多个程序同时运行，所以，多个程序通常会一起加载到主内存中。在这种情况下，程序能否在内存中灵活安置就变得非常重要。如果我们用”符号引用“来写程序，我们就不用再担心程序的具体内存地址了。

比如与其直接写“跳转到地址 1000”，不如写“跳转到 `loop_start`”。编译器或汇编器会在编译时自动将 `loop_start` 解析为正确的地址。

此外，我们还可以编写一个名为 **loader（装载器）** 的工具，专门负责处理程序加载过程中的地址偏移等技术细节。这进一步简化了程序的编写与运行。

所以，使用符号的程序其实是**非常强大又方便**的。

（下面是对 *"我们可以将程序加载到内存中的任何位置，而不必限定在地址0处。只要我们知道程序使用的基地址，它就可以在内存的任意位置正确运行。"* 这句话的理解）

![](../../../img/Pasted%20image%2020250807002710.png)

![](../../../img/Pasted%20image%2020250807002732.png)

![](../../../img/Pasted%20image%2020250807002756.png)


### Iteration

`Iteration` （迭代）就是指**重复做某件事**，通常是为了逐步接近一个目标或得出最终结果。

下面是用迭代计算从1加到n的和（n是输入来确定）

![](../../../img/Pasted%20image%2020250807003623.png)

建议：先写伪代码，并检查伪代码，然后再将伪代码翻译成机器语言，这样就能将阅读、编写机器代码的任务减少到简单地从伪代码翻译成机器语言的任务。最后，建议在纸上测试生成的程序（或者用文本编辑器）

![](../../../img/Pasted%20image%2020250807003543.png)

然后，我们将讨论[Pointers、Input、Output](Pointers、Input、Output.md) 。