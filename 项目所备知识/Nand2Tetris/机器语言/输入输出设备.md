
I/O设备主要用于：
- 从用户获取数据
- 向用户展示数据（显示数据）


### 输出设备（显示元素）——屏幕

如何将数据显示在屏幕上，其实是依靠屏幕存储器映射。

![](../../../img/Pasted%20image%2020250805171138.png)

屏幕其实是”读取内存中的某一块区域“来显示内容，这块内存叫做”屏幕映射内存“。显示器会不停刷新这一块内存，将想要展示的数据展示出来。

所以，如果我是一名程序员，我只能用`0` 和 `1` ，如果我想在显示单元上写点东西，我能做的就是简单的操作内存中的一些**位**。

我们必须在非常具体的位置打开和关闭像素才能影响这个特定的输出。


该课程所用的Hack Computer假设的物理显示屏，如图，可以将其看作一个表或矩阵，由256行和512列组成，其中每个”格子“就是一个像素，我们可以打开像素，也可以将其关闭。

![](../../../img/Pasted%20image%2020250805173336.png)

该如何控制呢？
内存映射，在这里是一系列16位值

8k * 16

左图是本课程中一款名为 `Screen` 的8k芯片，它的行为与存储单元完全相同——我们可以从中检索数据，也可以写入数据。
左图每16位（每一行）称作 `1 word`。

![](../../../img/Pasted%20image%2020250805175611.png)

右侧是二维，左侧是一维
当我们访问内存时，我们只能在一个区块中检索16位，而无法一次只访问1bit。也就是我们一次操作需要操作16位，如果想写入一位，则需要先找到其位置在哪一块，将这块（16位）取出，再找到其对应这16位的位置才能写入。因此，I\O操作始终是16位操作。

图中内存的前32word（0~31）对应显示屏的第一行像素
![](../../../img/Pasted%20image%2020250805180416.png) ^ac432a

在向右屏幕内存映射中操作的寄存器的地址：
i = 32 * row + col / 16（去掉余数）

余数用来对应相应word中的哪一位

若单看Screen这个芯片，我们可设其地址从0x0000开始来访问，但由于屏幕内存映射是属于RAM的一部分，该部分在RAM中的地址却不是从0x0000开始的，如果我访问整个RAM，就需要用偏移量，也就是相对位置来表示其位置。

屏幕区域的起始地址（基址）为16384

如果我们直接通过Screen芯片写入屏幕，就可以从地址 `0` 开始写：

`word = Screen[32 * row + col / 16]`

如果我们被告知：屏幕确实是整个内存（RAM）的一部分，那我们就需要把Screen的基址加进去：

`word = RAM[16384 + 32 * row + col / 16]`

读和写是常规的RAM操作


### 输入设备——键盘

RAM中还有一个称为键盘内存映射的区域
![](../../../img/Pasted%20image%2020250805184156.png)

为了表示键盘，我们需要的位数不超过16位，因此，键盘内存映射是一个单一寄存器（16位寄存器）。
![](../../../img/Pasted%20image%2020250805184347.png)

我们有一个特殊芯片，叫做Keyboard，它又是一个16位寄存器

如何运作？当按下键盘上的按键时，这个按键对应的scan code（对应的值，就像符号字母对应的ASCLL码一样）通过电缆传输并显示在键盘存储器映射中。 ^f7ee2c

例如，如果我点击数字4这个按键，其对应值是52，在通过电缆传输，将52以二进制的形式显示在芯片中。

如果键盘没有被触碰，则显示0。（用于辨认是否按下按键）

下列是一些对应值：
![](../../../img/Pasted%20image%2020250805190429.png)

![](../../../img/Pasted%20image%2020250805190605.png)

与本文有关的内容—— [Input / Output](Pointers、Input、Output.md#Input%20/%20Output) 。