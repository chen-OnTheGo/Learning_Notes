![](../../../img/Pasted%20image%2020250806162449.png)

在低级程序（低级程序语言，比如汇编语言）里，我们没有高级语言那样的变量名，操作的基本单位就是寄存器和内存。

最常见的两个寄存器是 **D register（D寄存器）** 和 **A register（A寄存器）** ，它们都在CPU里面。

其中 `D register` 是数据寄存器（Data Register），它可以存一组 16位 的数值。
`A register` 可以保存数据值或地址，具体取决于程序员想如何使用该寄存器。

还有个 `M register` ，也叫内存寄存器，指的是当前 `A register` 指向的RAM中的那一块内存。所以当我们设置 `A = 100` ，那么 `M` 就代表RAM中地址为 `100` 的那块内容。

所以在低级语言中，我们不再用 `int x = 5;` 这种高级语法，而是直接告诉电脑：

- 把这个值放到某个寄存器里（D, A）
- 或者写到某个内存地址上（通过 A 指向，M 访问）
- 需要记住的是，**`M` 只是 A 指向的那个内存单元而已**


### 举例

![](../../../img/Pasted%20image%2020250806163813.png)

第一个例子，我们需要实现 `D = 10` 。当我们查阅手册，发现没有直接将10赋值给 `D register` 的这种操作，所以就需要间接完成这一动作。所以我们用 `@10`  [将 `A register` 的值设置为  `10`](Hack语言规范.md)，再将 `A register` 的值赋值给 `D register` 。

第二个例子，将D register中的值加一。由于我们可以通过 `ALU` 来执行加一操作，所以我们直接将 D register中的值加一，再赋值给自身。

第三个例子，需要把内存中地址为17的值读取出来，放进 D register里。我们直接将A register的值设置成 17，由于M register是A register指向RAM中的那一块内存（地址为17）的值，所以直接将M register的值赋值给 D register。
......

![](../../../img/Pasted%20image%2020250806170809.png)

当我们将写好的程序加载到内存中时，空格、注释会被忽略，真正起到作用的指令会以一行一行的形式展现，当计算机开始运行时，就会从第一条指令开始一条一条地执行指令。

但是，**计算机并不知道“程序结束”**，除非我们明确告诉它。图中的指令并没有告诉计算机什么时候停止运行，所以计算机就不停地往下运行空白的指令，它失控了。

![](../../../img/Pasted%20image%2020250806171835.png)


![](../../../img/Pasted%20image%2020250806171225.png)

有些bad Hacker就会抓住这一特性，写一些恶意程序并悄悄将其放在内存的某个下游位置。然后，天真的用户运行了自己的程序，当用户的程序运行完后，计算机会继续执行内存中接下来的内容。而当执行到Hacker事先埋下的恶意代码时——砰，一些危险操作被执行了，比如删除用户计算机上的随机文件。

![](../../../img/Pasted%20image%2020250806171925.png)

这种攻击叫做 [NOP slide](NOP%20slide.md)。

我们该如何避免这个问题？准确地说，我们应该怎么开正确终止该程序？

我们需要明白的一点是，计算机永远不会停滞不前，即使不触摸键盘，它也总是会做点什么—— 有许多进程在后台运行。

所以，在被黑客入侵的计算机中，为了不让计算机做一些疯狂的事，我们不妨让计算机做一些我们控制的事情。所以我们能做的就是用**无限循环**结束程序：

![](../../../img/Pasted%20image%2020250806173725.png)

这样，虽然计算机在无限循环，但其执行的都是我们能够控制的，是我们预期的。

与本节有关的Hack语言请转到[Hack语言规范](Hack语言规范.md#^enhanceReadability)

接下来我们将讨论[Branching、Variables and Iteration](Branching、Variables%20and%20Iteration.md)。