本节我们将讨论如何处理Pointer（指针），以及如何编写操纵输入和输出设备的程序。

### Pointer

```
	for (i = 0; i < n; i++) {
		arr[i] = -1
	}
```

这是一段我们经常在高级语言课程中看到的一个练习，在这里，我们操作了一个名为 `arr` 的数组。用高级语言写很容易，那如果我们必须将其降至机器语言水平时，又该如何code呢？

我们必须意识到的一件事就是 —— 数组的概念在编译器翻译中消失了。对机器语言而言，数组只是**内存中的一段**，以及知道该段的**基址**和程序员决定声明的数组**长度**。

如果我们假设数组从`RAM[100]` 开始，并对这个数组前十个元素设置成 -1。

```
	// Suppose that arr = 100 and n = 10
	
	// arr = 100
	@100
	D=A
	@arr
	M=D

	// n = 10
	@10
	D=A
	@n
	M=D

	// initialize i = 0
	@i
	M=0

// Code continues...
```

上面这段代码则是用Hack语言对 `arr` 、 `n` 、`i` 的声明和赋值，这在RAM时这样体现的：

![](../../../img/Pasted%20image%2020250807113108.png)

三个变量分别被放在RAM地址为[16、17、18](Branching、Variables%20and%20Iteration.md#^74931a)里。

接下来我们使用Hack语言来实现for循环。我们要做的第一件事就是将终止条件翻译成机器语言，所以如果 `i == n` 则转到 `END` 。

```
(LOOP)
	// if (i == n) goto END
	@i
	D=M
	@n
	D=M-D
	@END
	D;JEQ

	// RAM[arr + i] = -1
	@i
	D=M
	@arr
	A=D+M
	M=-1

	// i++
	@i
	M=M+1

	@LOOP
	0;JMP

(END)
	@END
	0;JMP
```

像 `arr` 和 `i` 这样的**存储内存地址的变量**就叫做 `Pointer`(指针)。（不仅仅是在Hack语言中叫Pointer，在任何语言中都被称为Pointer）Pointer

如何访问指针指向的内容？
1. 把这个地址放进地址寄存器（比如 A 寄存器）
2. 然后才能用 `M` 来访问这个地址里的内容

举例：
```
	@arr
	D=M     // 现在 D = arr 中的值（一个地址）
	@A      // 这是伪代码，真实的做法如下
	@0
	A=D     // 把 D 中的地址放进 A 寄存器
	D=M     // 现在 D = 那个地址中的值
```

### Input / Output

在这一部分，我们将看到当我们编写与屏幕和其他类似外围设备交互的代码时，指针操作是如何发挥作用的。

我们主要谈两个标准的输入和输出设备——[屏幕和键盘](输入输出设备.md)。

![](../../../img/Pasted%20image%2020250807134143.png)


#### 屏幕

下面是在屏幕上画出一个宽16长`RAM[0]`的方块的伪代码。

```
// for (i = 0; i < n; i++) {
//     draw 16 black pixels at the
//     beginning of row 1
// }

addr = SCREEN    // 屏幕内存的基址
n = RAM[0]    // 从内存地址0中读取n，即想画多少行
i = 0

LOOP:
	if i > n goto END
	RAM[addr] = -1
	// advances to the next row
	addr = addr + 32
	i = i + 1
	goto LOOP

END:
	goto END
```

为什么会给 `RAM[addr]` 赋值 `-1` ？
因为在计算机中负数通常用**二进制的”补码“形式**表示，而 `-1` 的补码是 `1111 1111 1111 1111` ，由于一个屏幕行用一个 word（16 位）控制 ，所以恰好是每word16个像素都画上。

为什么 `addr + 32` 因为在本课程中设计的屏幕[每行有512个像素](输入输出设备.md#^ac432a)，512/16 = 32，所以要跳到下一行，就需要跳过32个word。

画出的效果是这样的：
![](../../../img/Pasted%20image%2020250807120943.png)

将上面的伪代码翻译成机器语言：

```
// Draws a filled rectangle at the screen's top left corner, 
// withe width of 16 pixels and height of RAM[0] pixels.
// Usage: put a non-negative number (rectangle's height) in RAM[0]

// addr = 16384 (screen's base address)
@SCREEN
D=A
@addr
M=D

// n = RAM[0]
@0
D=M
@n
M=D

// i = 0
@i
M=0

// if i > n goto END
(LOOP)
	@i
	D=M
	@n
	D=D-M
	@END
	D;JGT

	// RAM[addr] = 1111 1111 1111 1111
	@addr
	A=M    // ??为什么要这一步
	M=-1

	// i++
	@i
	M=M+1
	// addr = addr + 32
	@32
	D=A
	@addr
	M=D+M
	@LOOP
	0;JMP    //goto LOOP

(END)
	@END
	0;JMP
```

关于上面代码标出的 `A=M` 的理解：

- `@addr`：这行代码的意思是“选择地址为 `addr` 变量所在内存位置的寄存器”。假设编译器把 `addr` 变量放在了 RAM[16]，那么这行代码就相当于 `@16`。此时，`A` 寄存器的值是 `16`。
- `A=M`：这行代码的意思是“把 `A` 寄存器所指向的内存地址中的值，赋给 `A` 寄存器本身”。
    - `A` 寄存器当前是 `16`。
    - `M` 代表 `RAM[A]`，也就是 `RAM[16]`。
    - `RAM[16]` 里存的是什么？是你之前计算的屏幕基地址 `16384`。
    - 所以，`A=M` 执行后，`A` 寄存器的值就变成了 `16384`。
- `M=-1`：这行代码的意思是“把 `-1` (即 1111111111111111) 存入 `A` 寄存器所指向的内存地址”。
    - `A` 寄存器当前是 `16384`。
    - `M` 代表 `RAM[A]`，也就是 `RAM[16384]`。
    - 所以，`M=-1` 执行后，`RAM[16384]` 的值就变成了 `-1`。

**总结：** `@addr` 后面跟 `A=M` 是一种经典的 **间接寻址** 模式。它的作用是：“**取得 `addr` 变量中存储的地址，然后让 `A` 寄存器指向这个地址**”。这是操作动态内存地址（比如屏幕数组）的标准方法。没有 `A=M` 这一步，`M=-1` 就会把 `addr` 变量本身（存在 RAM[16]）设置为 `-1`，而不是把屏幕的起始位置设置为 `-1`。

#### 键盘

在前面一节中，我们简单讨论了键盘如何连接到计算机，特别是[连接到某个寄存器——register 24576](输入输出设备.md#输入设备——键盘)。

为了弄清楚用户在用键盘做什么，我们必须编写访问这个寄存器的代码，并检查对应的寄存器。因此，要检查当前正在处理哪个按键，就需要读取地址 `24576` 中的RAM内容。

通常，当我们编写计算机程序是，我们想让用户输入完整的字符串，比如用户名或密码之类的，就必须积累几个按键，直到用户按下Enter之类的按键。用低级语言编写这样的代码非常乏味，这就是为什么我们通常用高级语言来做，再将高级语言编译为机器语言之后，就可以得到预期的效果。

所以，在本次课程，我们只需要用Hack机器语言编程获取用户现在按的是哪个按键即可。


### 结语

下面借用Shimon教授的话（大概意思）：

>所以，就这样——我们完成了对 Hack 编程的探讨。
>
>我们已经讨论了每种编程语言中的经典元素，比如使用寄存器、分支、变量、迭代、指针，以及输入和输出。这些基本概念，构成了我们关于**低级编程**的内容。
>
>在结束本单元之前，我想简单谈谈“编译”的概念。其实，从我们前面单元中的例子来看，我们已经非常接近编译器的本质了。我们解释了如何用底层的机器语言手动编写程序。而实际上，把一种语言翻译成另一种语言，正是编译器的职责。
>
>可以说，编译器的作用，就是让你可以专注于高级语言的抽象，而不必担心 这个东西是如何被翻译成机器语言的所有细节。然而，为了达到同样的效果，在低级语言中，你必须非常清楚它的结构、限制和工作机制，并花费大量的精力去手动实现这些逻辑。
>
>而在本课程的第二部分，我们将真正开始构建一个**编译器**。它能够将用高级、基于对象的语言（类似你在普通编程课中学到的语言）编写的程序，转换成低级代码。我们会借助虚拟机和主机操作系统的服务，构建出一整套从高级语言到机器代码的翻译系统。如果你想深入了解这背后的逻辑层级与技术挑战，我强烈建议你继续学习课程的第二部分。
>
>最后，我希望现在你已经认识到，低级编程不仅仅是“低级”的，它直接面对机器，虽然简约，却也极具表现力和挑战性。
>这也是因为它太简约了，太斯巴达式了，也因为它的表现力如此出色，所以它也是一件非常深刻和微妙的事情。用机器语言编写程序是深刻的、微妙的，而且在智力上具有挑战性。
>
>这让我想起一句话：“**复杂的事物会让思维简单的人印象深刻，而简单的事物则打动那些真正老练的人。**”
>
>特别是当一种简单的事物仍然拥有强大表现力时，它们会给人留下深刻的印象。想想 Hack 语言——它只有两种指令形式，却足以表达**任意高级程序的全部功能**。任何你能用高级语言编写的程序，理论上都可以被转换成功能等价的 Hack 程序。


开始写本节的[项目](Item%20demand.md)。